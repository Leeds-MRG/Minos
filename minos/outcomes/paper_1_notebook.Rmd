---
title: "Paper 1 Notebook"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup}
knitr::opts_knit$set(root.dir = "/home/rob/Minos")
getwd()
```

```{r "preamble"}
#setwd("../..")
library(here)
source(here::here("minos", "transitions", "utils.R"))
source(here::here("minos", "transitions", "transition_model_functions.R"))
source(here::here("minos", "transitions", "paper_1_plots.R"))
library(dplyr)
library(texreg)
library(lme4)
library(glmnet)
library(mice)
library(sjPlot)
library(visreg)
library(ggplot2)
library(ggpattern)
library(VIM)
library(caret)
library(tidyverse)
library(performance)
library(broom.mixed)
library(ggridges)
library(ggmice)
library(MASS)
library(qpcR)
library(cv)
library(Rcpp)

save.path <- "minos/outcomes/paper1_plots/"
#raw.data.dir <- "data/raw_US/"
raw.data.dir  <- "data/composite_US/"
mice.data.dir <- "data/composite_US/"
final.data.dir <- mice.data.dir
```


##############################
# baseline and presentation ##
##############################


```{r "raw_data_processing"}

#TODO RMSE AND PRESS STATS FOR CROSS VAL.  RMSE(predictions, test_data$outcomeName)
#TODO MAKE SURE CROSS VAL ON BOTH STAGES.
# get raw data file names from 2011-2013.
filelist <- list.files(raw.data.dir,
                       include.dirs = FALSE,
                       full.names = TRUE,
                       pattern = '[0-9]{4}_US_cohort.csv')[3:5]#[21:23] # get files for 2011-2013.
# load raw data.
raw.data <- do.call(rbind, lapply(filelist, read.csv))

# baseline OLS model formula. 
raw_model_formula_string <- "I(log((80 -SF_12)+10)) ~ factor(sex) + 
                  relevel(factor(ethnicity), ref='WBI') + 
                  scale(age) + 
                  factor(education_state) + 
                  factor(labour_state) + 
                  relevel(factor(NSSEC), ref=1) +
                  relevel(factor(region), ref='London') +
                  scale(hh_income)"

# Calculate required variables for regression to run. 
raw_model_formula <- as.formula(raw_model_formula_string)
variables <- all.vars(raw_model_formula)

# get only needed variables and replace missing codes with NA.
raw.data <- update_column_names(raw.data)
raw.data <- raw.data[, append(variables, c("time", 'pidp','hidp', 'weight'))]
raw.data <- replace.missing(raw.data)


raw.data <- drop_na(raw.data)

# get raw data file names.
full.raw.filelist <- list.files(raw.data.dir,
                       include.dirs = FALSE,
                       full.names = TRUE,
                       pattern = '[0-9]{4}_US_cohort.csv')[3:13] #[21:30] # get files for 2011-2013.
# load raw data.
full.raw.data <- do.call(rbind, lapply(full.raw.filelist, read.csv))
full.raw.data <- update_column_names(full.raw.data)

# get only needed variables and replace missing codes with NA.
full.raw.data <- full.raw.data[, append(variables, c("time", 'pidp', 'hidp', 'weight'))]
full.raw.data <- replace.missing(full.raw.data)
```


```{r "OLS"}

# calculate baseline OLS model.
sf12.lm <- lm(raw_model_formula_string,
              data= raw.data)
# print summary statistics
#print(summary(sf12.lm))

# create save.path if it doesn't exist and save OLS coefficients as a latex table there. 
create.if.not.exists(save.path)
write_coefs <- T
if (write_coefs)
{
  texreg_file <- paste0(save.path, 'SF12_OLS_coefficients.txt')
  tex_label <- paste0("table: baseline_OLS_coefficients") 
  tex_headers <- c(texreg::names2latex("Baseline SF_12 OLS"))
  tex_caption <- texreg::names2latex(get_tex_table_caption("SF_12", "ols"))    
  texreg(sf12.lm, # what model to save coefs for. 
         file=texreg_file,  # where to save.
         custom.model.names = tex_headers, # title of table.
         stars = c(0.001, 0.01, 0.05), # p-value significance symbols. 
         digits=4, # p values significant figures.
         caption=tex_caption, # \caption command option. 
         label = tex_label, # \label command option. 
         dcolumn=T,# nice column alignment. 
         booktabs=T, # nice hlines. (recommended)
         tabular=T,# tabular env.
         single.row = T, # nicer one row formatting.
         longtable=T, #Â allows tables to wrap over pages
         use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
         fontsize='tiny') # tiny font
}


# diagnostic plots for OLS presentation. 
forest_plot_lm(sf12.lm, paste0(save.path, "presentation_forest.pdf"))
log_forest_plot(sf12.lm, paste0(save.path, "presentation_forest.pdf"))
qq_plot(resid(sf12.lm), paste0(save.path, "presentation_qq.pdf"))
residual_density_plot(res=resid(sf12.lm), file_name=paste0(save.path, "presentation_residual_density.pdf"), guide="normal")

squareRootRes <- sqrt(abs(scale(resid(sf12.lm))))
fitted_residuals <- as.data.frame(cbind(fitted(sf12.lm), squareRootRes))
colnames(fitted_residuals) <- c("fitted", "sqrt_residuals")
fitted_residual_plot(fitted_residuals, paste0(save.path, "presentation_scale_location_plot.pdf"))

# raw data handovers from 2011-2020. 

start.data <- raw.data[which(raw.data$time==2013),]
start.data.colnames <- colnames(start.data)
start.data.colnames[which( colnames(start.data)=="job_sec" )] <- "NSSEC"
start.data.colnames[which( colnames(start.data)=="hh_netinc" )] <- "hh_income"
start.data.colnames[which( colnames(start.data)=="labour_state_raw" )] <- "labour_state"
colnames(start.data) <- start.data.colnames
handover.data <- start.data[, c("pidp", "SF_12", "hidp", "time")]
rolling.data <- start.data 

for (i in 1:8){
  rolling.data$SF_12 <- (80-(exp(predict(sf12.lm, rolling.data))-10))
#  start.data$SF_12 <- predict(sf12.lm, rolling.data)
  rolling.data[, 'time'] <- rolling.data[, 'time'] +1
  handover.data <- rbind(handover.data, rolling.data[, c("pidp", "hidp", "SF_12", "time")])
}


handover_boxplots(full.raw.data, handover.data, "SF_12", save.path, "ols_SF12_boxplot")
density_ridges(full.raw.data, "SF_12", save=TRUE, save.path=save.path, filename.tag = "ols_raw_ridges")
density_ridges(handover.data, "SF_12", save=TRUE, save.path=save.path, filename.tag = "ols_handover_ridges")

# remove raw data to prevent lag. 
#rm(raw.data)
#rm(full.raw.data)
```

```{r raw cross val}
# Baseline cross val.

trControl <- trainControl(method = "cv", number=5, returnData=F, trim=T, verboseIter = TRUE)

raw.cross.val.sf12.model <- train(as.formula(raw_model_formula_string), data = raw.data,
               method = "lm",
               trControl = trControl)

print(RMSE(raw.cross.val.sf12.model))

#print(PRESS(raw.cross.val.sf12.model))
```


##################################
# missingness ####################
##################################

```{r mice preprocessing}
# load in all 2009-2020 datasets
mice.filelist <- list.files(mice.data.dir,
                       include.dirs = FALSE,
                       full.names = TRUE,
                       pattern = '[0-9]{4}_US_cohort.csv')
mice.data <- do.call(rbind, lapply(mice.filelist, read.csv))

mice.data <- update_column_names(mice.data)

# missingness MICE model formula
mice_formula_string <- "I(log(SF_12+10)) ~ 
                        factor(sex) + 
                        relevel(factor(ethnicity), ref='WBI') + 
                        scale(age) + 
                        factor(education_state) + 
                        factor(labour_state) + 
                        relevel(factor(NSSEC), ref=1) +
                        relevel(factor(region), ref='London') +
                        scale(hh_income) + 
                        scale(I(hh_income**2)) +
                        factor(housing_quality) +
                        factor(neighbourhood_safety) + 
                        factor(loneliness) +
                        ncigs +
                        nutrition_quality"

mice_model_formula <- as.formula(mice_formula_string)
variables <- all.vars(mice_model_formula)

# get required variables and replace missing value codes.
mice.data <- replace.missing(mice.data)

# preserving key columns that aren't imputed for later. cant be included. in imputation set due to perfect seperation. 
mice.pidp <- mice.data[which(mice.data$time %in% c(2011, 2012, 2013)), "pidp"]
mice.hidp <- mice.data[which(mice.data$time %in% c(2011, 2012, 2013)), "hidp"]
mice.time <- mice.data[which(mice.data$time %in% c(2011, 2012, 2013)), "time"]
mice.weights <- mice.data[which(mice.data$time %in% c(2011, 2012, 2013)), "weight"]

mice.2018.pidp <- mice.data[which(mice.data$time %in% c(2016, 2017, 2018)), "pidp"]
mice.2018.hidp <- mice.data[which(mice.data$time %in% c(2016, 2017, 2018)), "hidp"]
mice.2018.time <- mice.data[which(mice.data$time %in% c(2016, 2017, 2018)), "time"]
mice.2018.weights <- mice.data[which(mice.data$time %in% c(2016, 2017, 2018)), "weight"]

lm.no.mice <- lm(mice_formula_string, data=mice.data)
forest_plot(lm.no.mice,  paste0(save.path, "no_mice_forest.pdf"))
log_forest_plot(lm.no.mice,  paste0(save.path, "no_mice_forest.pdf"))
```




```{r MICE}

#getting MICE data for 2011-2020. imputing loneliness, housing, neighbourhood. 
# set up MICE and cache data
# plots of missingness pre and post raw US
# figures of convergence and difference in distribution.


imp_columns <- c("SF_12",
                 'sex',
                 "NSSEC",
                 "education_state",
                 "labour_state", 
                 "region", 
                 "ethnicity", 
                 "age", 
                 "time", 
                 "hh_income",
                 "housing_quality",
                 "neighbourhood_safety",
                 "loneliness",
                 "ncigs",
                 'nutrition_quality'
)

# structure plots for adding in auxliary variables

#pdf("papers/phd1/plots/total_missingness_structure2.pdf")
#aggr(subset(final.data[,reg_columns], select=-c(y)), sortVars=T,  oma=c(8,4,4,4), numbers=T, cex.axis=1.0, col = c(blue, orange), prop=F, combined=T, cex.numbers=0.5)
#dev.off()

aggr_columns <- c("SF_12",
                 "NSSEC",
                 "education_state",
                 "labour_state", 
                 "ethnicity", 
                 "hh_income",
                 "neighbourhood_safety",
                 "loneliness",
                 "ncigs",
                 'nutrition_quality'
)
# initial missingness structure for 2011-2013 US data.
pdf(paste0(save.path, "total_missingness_structure1.pdf"))
aggr(mice.data[,aggr_columns], sortVars=T, prop=T, combined=F,varheight=T, oma=c(10,5,1,2), gap=0)
dev.off()



mice_columns <- c("age", 
                  "region", 
                  #"heating", 
                  "NSSEC", 
                  "ncigs",
                  "education_state",            
                  "ethnicity",
                  "loneliness",
                  "sex", 
                  "SF_12",
                  #"SF_12p",
                  #"smoker",
                  "nkids",       
                  "behind_on_bills",
                  "financial_situation",
                  "future_financial_situation",
                  "likely_move",
                  "ghq_depression",
                  "ghq_happiness",
                  "clinical_depression", 
                  "scsf1",
                  "health_limits_social",
                  #"hhsize",
                  #"housing_tenure",
                  #"urban", 
                  "housing_quality",
                  "hh_income",
                  "neighbourhood_safety",
                  "labour_state",
                  #"yearly_energy",
                  "nutrition_quality"
                  #"hh_comp", 
                  #"marital_status"
)


mice.data$ethnicity <- factor(mice.data$ethnicity)
mice.data$labour_state <- factor(mice.data$labour_state)
mice.data$region <- factor(mice.data$region)
mice.data$loneliness <- factor(mice.data$loneliness)
#mice.data$heating <- factor(mice.data$heating)
#mice.data$job_sec <- factor(mice.data$job_sec)
#mice.data$education_state <- factor(mice.data$education_state)
#mice.data$sex <- factor(mice.data$sex)
#mice.data$smoker <- factor(mice.data$smoker)
#mice.data$behind_on_bills <- factor(mice.data$behind_on_bills)
#mice.data$ghq_depression <- factor(mice.data$ghq_depression)
#mice.data$ghq_happiness <- factor(mice.data$ghq_happiness)
#mice.data$clinical_depression <- factor(mice.data$clinical_depression)
#mice.data$scsf1 <- factor(mice.data$scsf1)
#mice.data$health_limits_social <- factor(mice.data$ghq_depression)
#mice.data$housing_tenure <- factor(mice.data$housing_tenure)
#mice.data$urban <- factor(mice.data$urban)
#mice.data$marital_status <- factor(mice.data$marital_status)





load_cache <- T
if (load_cache) {
  mice_set <- readRDS("data/transitions/MICE_set.rds")
} else {
  #n_iter <- 30
  #max_iter <- 10
  n_iter <- 1
  max_iter <- 1
  ignore_cols = c("birth_year")
  # future mice is parallelised version of MICE.
  mice_set <- mice(data = mice.data[mice.data$time %in%  c(2013, 2020), imp_columns],
                   m = n_iter, maxit = max_iter,
                   remove.collinear=T)
  
  #mice_set <- with_progress(futuremice(data = mice.data[, mice_columns], #method=method,
  #                m = n_iter, maxit = max_iter,
  #                 remove.collinear=T, quiet=F,
  #                 progressor = progressr::handlers("progress")))
  saveRDS(mice_set, "data/transitions/MICE_set.rds")
}

```

```{r mar_analyses}

aux_vars <- c("SF_12",
              #"SF_12p",
              #"smoker",
              "nkids",       
              "behind_on_bills",
              "financial_situation",
              "future_financial_situation",
              "likely_move",
              "ghq_depression",
              "ghq_happiness",
              "clinical_depression", 
              "scsf1",
              "health_limits_social")
ggmice::plot_corr(mice.data[, aux_vars])

pre.mice.lm <- lm(mice_formula_string, data=mice.data, weights = weight)
forest_plot(pre.mice.lm , paste0(save.path,'mice_SF12_forest.pdf'))
log_forest_plot(pre.mice.lm , paste0(save.path,'mice_SF12_forest.pdf'))
qq_plot(resid(pre.mice.lm ), paste0(save.path, "mice_qq.pdf"))
```


```{r mice_output}

# only looking at 2011-2013 subset of data. convert to data frame, subset, and back to MICE mids. 
# also adding variables that can't be imputed back in. pidp time weight.
mice.long <- complete(mice_set, action = "long", include=T) #
#mice.long$SF_12 <- mice.long$SF_12 + 10
#mice.long.subset <- mice.long[which(mice.long$time %in% c(2011, 2012, 2013)), ]

mice.long$pidp <- mice.data$pidp
mice.long$hidp <- mice.data$hidp
mice.long$weight <- mice.data$weight
mice.long$time <- mice.data$time
mice.long <- update_column_names(mice.long)
mice_set.full <- as.mids(mice.long)

mice.long.subset <- mice.long[which(mice.long$time %in% c(2011, 2012, 2013)), ]


as.mids2 <- function (data, .imp = 1, .id = 2) 
    {
      # paste added to get numerical value if .imp is factor
      ini <- mice(data[data[, .imp] == 0, -c(.imp, .id)], m = max(as.numeric(paste(data[, .imp]))), maxit = 0)
      names <- names(ini$imp)
          if (!is.null(.id)) {
            rownames(ini$data) <- data[data[, .imp] == 0, .id]
          }
          for (i in 1:length(names)) {
            # -1 removed and paste added to get numerical value if .imp is factor
            for (m in 1:(max(as.numeric(paste(data[, .imp]))))) {
              if (!is.null(ini$imp[[i]])) {
                indic <- data[, .imp] == m & is.na(data[data[, .imp] == 0, names[i]])
                ini$imp[[names[i]]][m] <- data[indic, names[i]]
          }
        }
      }
      return(ini)
    }
mice_set.subset <- as.mids2(mice.long.subset) # bug in as.mids can't handle this. nice fix here. https://stats.stackexchange.com/questions/138769/something-wrong-with-as-mids-from-mice-package-in-r

# convergence plots needs to be done on full mice subset. 
pdf(paste0(paste0(save.path,"ols_mice_convergence.pdf")))
#print(plot(mice_set, SF_12 = SF_12 ~ .it | .ms))
plot_trace(mice_set, "SF_12") + theme(legend.position="none")
dev.off()

# pooling OLS estimate together. 
mice.sf12.lm <- with(mice_set.subset, lm(as.formula(mice_formula_string)))
final.pool<- pool(mice.sf12.lm)

# summary stats for final pool. 
pooled_lm <- mice.sf12.lm$analyses[[1]]
pool.sum <- summary(final.pool)
pooled_lm$coefficients = pool.sum$estimate
mice.preds<- predict(pooled_lm)
pool.r.squared(final.pool)

# mice objects dont go in forest plot annoyingly. move coefficients over to a
# dummy lm that sjPlot::plot_models can read.
mice.lm.object <- summary(lm(mice_formula_string, data = complete(mice_set.subset)))
mice.lm.object$coefficients[,1] <- pool.sum$estimate
mice.lm.object$coefficients[,2] <- pool.sum$std.error
mice.lm.object$coefficients[,3] <- pool.sum$statistic
mice.lm.object$coefficients[,4] <- pool.sum$p.value

# making density plot. 
res <- as.data.frame(predict(pooled_lm))
real <- as.data.frame(mice.data$SF_12)
res$type <- c("Predicted")
real$type <- c("Real")
colnames(res) <- c("SF12", 'type')
colnames(real) <- c("SF12", 'type')
hist.data <- rbind(res,real)
hist.data <- tidyr::drop_na(hist.data)

res <- as.data.frame(resid(pooled_lm))
residual_density_plot(res, paste0(save.path,'mice_ols_densities.pdf'), guide='normal')

# coefficient forest plot. 
forest_plot(mice.lm.object, paste0(save.path,'mice_SF12_forest.pdf'))
log_forest_plot(mice.lm.object, paste0(save.path,'mice_SF12_forest.pdf'))
qq_plot(resid(mice.lm.object), paste0(save.path, "mice_qq.pdf"))



# writing coefficients table for MICE. 
# is there a version for pool table?
write_coefs <- T
if (write_coefs)
{
  texreg_file <- paste0(save.path, 'SF12_MICE_OLS_coefficients.txt')
  tex_label <- paste0("table: MICE_OLS_coefficients") 
  tex_headers <- c(texreg::names2latex("MICE SF_12 OLS"))
  tex_caption <- texreg::names2latex(get_tex_table_caption("SF_12", "ols"))    
  texreg(mice.lm.object, # what model to save coefs for. 
         file=texreg_file,  # where to save.
         custom.model.names = tex_headers, # title of table.
         stars = c(0.001, 0.01, 0.05), # p-value significance symbols. 
         digits=4, # p values significant figures.
         caption=tex_caption, # \caption command option. 
         label = tex_label, # \label command option. 
         dcolumn=T,# nice column alignment. 
         booktabs=T, # nice hlines. (recommended)
         tabular=T,# tabular env.
         single.row = T, # nicer one row formatting.
         longtable=T, #Â allows tables to wrap over pages
         use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
         fontsize='tiny') # tiny font
  
  #Â same again for MICE pool. 
  texreg_file <- paste0(save.path, 'SF12_MICE_pool_OLS_coefficients.txt')
  tex_label <- paste0("table: MICE_pool_OLS_coefficients") 
  tex_headers <- c(texreg::names2latex("MICE SF_12 OLS Pool"))
  tex_caption <- texreg::names2latex(get_tex_table_caption("SF_12", "ols"))    
  texreg(final.pool, # what model to save coefs for. 
         file=texreg_file,  # where to save.
         custom.model.names = tex_headers, # title of table.
         stars = c(0.001, 0.01, 0.05), # p-value significance symbols. 
         digits=4, # p values significant figures.
         caption=tex_caption, # \caption command option. 
         label = tex_label, # \label command option. 
         dcolumn=T,# nice column alignment. 
         booktabs=T, # nice hlines. (recommended)
         tabular=T,# tabular env.
         single.row = T, # nicer one row formatting.
         longtable=T, #Â allows tables to wrap over pages
         use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
         fontsize='tiny') # tiny font
}



# writing coefficients table for MICE. 
# is there a version for pool table?
write_coefs <- T
if (write_coefs)
{
  texreg_file <- paste0(save.path, 'SF12_without_MICE_OLS_coefficients.txt')
  tex_label <- paste0("table: without_MICE_OLS_coefficients") 
  tex_headers <- c(texreg::names2latex("Without MICE SF_12 OLS"))
  tex_caption <- texreg::names2latex(get_tex_table_caption("SF_12", "without_mice"))    
  texreg(mice.lm.object, # what model to save coefs for. 
         file=texreg_file,  # where to save.
         custom.model.names = tex_headers, # title of table.
         stars = c(0.001, 0.01, 0.05), # p-value significance symbols. 
         digits=4, # p values significant figures.
         caption=tex_caption, # \caption command option. 
         label = tex_label, # \label command option. 
         dcolumn=T,# nice column alignment. 
         booktabs=T, # nice hlines. (recommended)
         tabular=T,# tabular env.
         single.row = T, # nicer one row formatting.
         longtable=T, #Â allows tables to wrap over pages
         use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
         fontsize='tiny') # tiny font
  
  #Â same again for MICE pool. 
  texreg_file <- paste0(save.path, 'SF12_MICE_pool_OLS_coefficients.txt')
  tex_label <- paste0("table: MICE_pool_OLS_coefficients") 
  tex_headers <- c(texreg::names2latex("MICE SF_12 OLS Pool"))
  tex_caption <- texreg::names2latex(get_tex_table_caption("SF_12", "ols"))    
  texreg(final.pool, # what model to save coefs for. 
         file=texreg_file,  # where to save.
         custom.model.names = tex_headers, # title of table.
         stars = c(0.001, 0.01, 0.05), # p-value significance symbols. 
         digits=4, # p values significant figures.
         caption=tex_caption, # \caption command option. 
         label = tex_label, # \label command option. 
         dcolumn=T,# nice column alignment. 
         booktabs=T, # nice hlines. (recommended)
         tabular=T,# tabular env.
         single.row = T, # nicer one row formatting.
         longtable=T, #Â allows tables to wrap over pages
         use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
         fontsize='tiny') # tiny font
}
#screenreg final.pool
```

############################
# validation ###############
############################

```{r mice cross validated nowcasting}
# split data into five
# transition models
# compare coefficients in plots. 

# training the model by assigning sales column
# as target variable and rest other column
# as independent variable

trControl <- trainControl(method = "cv", number=5, returnData=F, trim=T, verboseIter = TRUE)

cross.val.sf12.model <- train(as.formula(mice_formula_string), data = complete(mice_set.subset, 1, include=F),
               method = "lm",
               trControl = trControl)

print(RMSE(cross.val.sf12.model))

# come back to this. 
#with(mice_set.subset,  train(as.formula(mice_formula_string),
#               method = "lm",
#               trControl = trControl))
 
# printing model performance metrics
# along with other details
#print(summary(cross.val.sf12.model))

write_coefs <- T
if (write_coefs)
{
  texreg_file <- paste0(save.path, 'SF12_cross_val_OLS_coefficients.txt')
  tex_label <- paste0("table: ols_cross_val_coefficients") 
  tex_headers <- c(texreg::names2latex("5-Fold Cross Validated SF_12 OLS"))
  tex_caption <- texreg::names2latex(get_tex_table_caption("cv_SF_12", "ols"))    
  texreg(summary(cross.val.sf12.model), # what model to save coefs for. 
         file=texreg_file,  # where to save.
         custom.model.names = tex_headers, # title of table.
         stars = c(0.001, 0.01, 0.05), # p-value significance symbols. 
         digits=4, # p values significant figures.
         caption=tex_caption, # \caption command option. 
         label = tex_label, # \label command option. 
         dcolumn=T,# nice column alignment. 
         booktabs=T, # nice hlines. (recommended)
         tabular=T,# tabular env.
         single.row = T, # nicer one row formatting.
         longtable=T, #Â allows tables to wrap over pages
         use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
         fontsize='tiny') # tiny font
}
```



```{r mice_cross_val_handovers_data}
# boxplots for handovers
#.estimating from 2014-2020.
# get data for 2013- 2020
# run 2013 pop through transition probability model a few times. 
# profit. 
# run it through model a few times
# compare with real data in boxplots and ridgelines. 

crossval.mice.data <- complete(mice_set.full, 1, include = F)
crossval.mice.data <- replace.missing(crossval.mice.data)
crossval.mice.data <- drop_na(crossval.mice.data)
crossval.mice.data <- update_column_names(crossval.mice.data)
```


```{r mice_handovers}
start.data <- crossval.mice.data[which(crossval.mice.data$time==2013),]
rolling.data <- start.data#[, c("pidp", "SF_12", "time")]
handover.data <- rolling.data[, c("pidp", "hidp", "SF_12", "time")]
for (i in 1:8){
  rolling.data$SF_12 <- exp(predict(pooled_lm, newdata = rolling.data))-10
  start.data$SF_12 <- rolling.data$SF_12
  rolling.data[, 'time'] <- rolling.data[, 'time'] +1
  handover.data <- rbind(handover.data, rolling.data[, c("pidp", "hidp", "SF_12", "time")])
}


handover_boxplots(crossval.mice.data, handover.data, "SF_12", save.path, "mice_SF12_boxplots")
density_ridges(crossval.mice.data, "SF_12", save=TRUE, save.path=save.path, filename.tag = "mice_raw_ridges")
density_ridges(handover.data, "SF_12", save=TRUE, save.path=save.path, filename.tag = "mice_validation_ridges")

```


```{r cross_val_mice_handovers}
start.data <- crossval.mice.data[which(crossval.mice.data$time==2013),]
rolling.data <- start.data
handover.data <- rolling.data[, c("pidp", "hidp", "SF_12", "time")]

for (i in 1:8){
  rolling.data$SF_12 <- exp(predict(cross.val.sf12.model, rolling.data))-10
  start.data$SF_12 <- rolling.data$SF_12
  rolling.data[, 'time'] <- rolling.data[, 'time'] +1
  handover.data <- rbind(handover.data, rolling.data[, c("pidp", 'hidp', "SF_12", "time")])
}


handover_boxplots(crossval.mice.data, handover.data, "SF_12", save.path, "crossval_SF12_boxplot")
density_ridges(crossval.mice.data, "SF_12", save=TRUE, save.path=save.path, filename.tag = "crossval_raw_ridges")
density_ridges(handover.data, "SF_12", save=TRUE, save.path=save.path, filename.tag = "crossval_validation_ridges")

```

###

```{r random_coefficients}

# for 100 iterations
randomised.mice.model.data <- data.frame()
random.mice.lm.object <- lm(mice_formula_string, data = complete(mice_set.subset, 1))


for (i in 1:100) {
  # choose a random OLS model
  #Â randomise its coefficients from MVN dist from MASS.
  #model.choice.ix <- ceiling(runif(1)*30)
  #model.choice <- mice.sf12.lm$analyses[model.choice.ix]
  model.choice <- random.mice.lm.object
  model.choice$coefficients <- MASS::mvrnorm(n=1, mu=mice.lm.object$coefficients[, 1], Sigma=vcov(mice.lm.object))
  # add to pool
  #Â commentary
  random.start.data <- crossval.mice.data[which(crossval.mice.data$time==2013),]
  #random.start.data[, c("run_id")] <- i
  #random.rolling.data <- random.start.data[, c("SF_12", "time", "run_id")]
  #random.handover.data <- rolling.data
  for (j in 1:7){
    random.start.data$SF_12 <- exp(predict(model.choice, random.start.data))-10
    #random.start.data$SF_12 <- random.rolling.data$SF_12
    #random.rolling.data[, 'time'] <- random.rolling.data[, 'time'] +1
    #random.handover.data <- rbind(random.handover.data, random.rolling.data)
  }
  individual.density <- density(random.start.data$SF_12)
  new.data.frame <- cbind(individual.density$x, individual.density$y, i)
  colnames(new.data.frame) <- c("SF_12", "Density", "run_id")
  randomised.mice.model.data <- rbind(randomised.mice.model.data, new.data.frame)

}

p <- ggplot(randomised.mice.model.data, aes(x=SF_12, y=Density, group=factor(run_id))) +
     geom_line(alpha=0.1) + ylim(0, 0.15) + xlim(15,60)
ggsave(paste0(save.path, "/", "randomised_coefficients_2020_density.pdf"))
#ggplot(randomised.mice.model.data, aes(x=SF_12, y=Density)) +
#    geom_line(alpha=0.2) + geom_ribbon()



```

### LASSO and variable selection. 

```{r lasso}
# just import from old paper
lasso.data <- tidyr::drop_na(complete(mice_set.subset))
X <- model.matrix(as.formula(mice_formula_string), data=lasso.data)
y <- lasso.data$SF_12
weight <- lasso.data$weight
cv.lasso <- cv.glmnet(X, y, family = "gaussian", weights = weight)
lasso <- glmnet(X, y, alpha = 1,  family = "gaussian", weights = weight)

# plots for this. 
  
pdf(paste0(save.path, 'ols_lasso_2013.pdf'))
plot(lasso, xvar = "lambda", label = T) 
abline(v = log(cv.lasso$lambda.min), col = "blue",lty=2)
abline(v = log(cv.lasso$lambda.1se), col = "red", lty=3)
legend('bottomright', legend=c("Minimum Standard Error", "First Standard Error"), col=c('blue', 'red'), lty=c(2, 3))
dev.off()

pdf(paste0(save.path, 'ols_cv_lasso_2013.pdf'))
plot(cv.lasso)
dev.off()

# bind two sets of coefficients into a data frame
# load them into a tex table using the latex package?
lasso.min.coefs <- coef(cv.lasso, s=cv.lasso$lambda.min)
lasso.1se.coefs <- coef(cv.lasso, s=cv.lasso$lambda.1se)
lasso_model_names <- c("Minimum Error", "First Standard Error")

texreg_file <- paste0(save.path, 'SF12_Lasso_coefficients.txt')
tex_label <- paste0("table: sf12_lasso_coefficients") 
tex_headers <- c(texreg::names2latex("Minimum Error"), texreg::names2latex("First Standard Error"))
tex_caption <- texreg::names2latex(get_tex_table_caption("SF_12", "lasso"))    
#lassoTexReg <-createTexreg(coef.names=rownames(lasso_coefs), coef = lasso_coefs[,1], se=lasso_coefs[,2], model.names=c("Minimum Error", "First Standard Error"))

lasso.min <-createTexreg(coef.names=rownames(lasso.min.coefs), coef = lasso.min.coefs[, "s1"])
lasso.1se <-createTexreg(coef.names=rownames(lasso.min.coefs), coef = lasso.1se.coefs[, "s1"])


#lassoTexReg2 <-createTexreg(coef.names=rownames(lasso_coefs), coef = lasso_coefs[,2])#, lasso_coefs[, 2]))#, pvalues=lasso_coefs[,2])
#matrixLassoTexReg <- matrixreg(list(lassoTexReg, lassoTexReg2))

texreg(c(lasso.min, lasso.1se), # what model to save coefs for. 
       file=texreg_file,  # where to save.
       custom.model.names = tex_headers, # title of table.
       caption=tex_caption, # \caption command option. 
       label = tex_label, # \label command option. 
       dcolumn=T,# nice column alignment. 
       booktabs=T, # nice hlines. (recommended)
       tabular=T,# tabulr env.
       single.row = T, # nicer one row formatting.
       longtable=T, #Â allows tables to wrap over pages
       use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
       fontsize='tiny') # tiny font

```




```{r weighted_ols}
# weighted ols using mice data.
sf12.lm.weighted <- with(mice_set.subset, lm(as.formula(mice_formula_string), weights = weight))
summary(sf12.lm.weighted)

#coefficients go here.
texreg_file <- paste0(save.path, 'SF12_weighted_OLS_coefficients.txt')
tex_label <- paste0("table: sf12_weighted_coefficients") 
tex_headers <- c(texreg::names2latex("SF_12 Weighted OLS"))
tex_caption <- texreg::names2latex(get_tex_table_caption("SF_12", "weighted_OLS"))    

texreg(pool(sf12.lm.weighted), # what model to save coefs for. 
       file=texreg_file,  # where to save.
       custom.model.names = tex_headers, # title of table.
       caption=tex_caption, # \caption command option. 
       label = tex_label, # \label command option. 
       dcolumn=T,# nice column alignment. 
       booktabs=T, # nice hlines. (recommended)
       tabular=T,# tabulr env.
       single.row = T, # nicer one row formatting.
       longtable=T, #Â allows tables to wrap over pages
       use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
       fontsize='tiny') # tiny font

```

```{r projected_data}

##REDO THIS
## GET MICE DATA 2011-2013. UPDATE WEIGHTS

# GET MICE DAT 2016-2018

# FIT TWO REGRESSIONS AND COMPARE. PARTICULARLY ASE DIFFERENCES.

# plots as with SF12
# get data with extrpolated weights for 2013-2018
# data at data/extrapolated_weights...



# creating 2016_data
mice_set.subset.2016_2018 <- mice.long[which(mice.long$time %in% c(2016, 2017, 2018)), ]
mice_set.subset.2016_2018$pidp <- mice.2018.pidp
mice_set.subset.2016_2018$hidp <- mice.2018.hidp
mice_set.subset.2016_2018$weight <- mice.2018.weights
mice_set.subset.2016_2018$time <- mice.2018.time
mice_set.subset.2016_2018 <- as.mids(mice_set.subset.2016_2018)


# getting updated weights for 2011-2013 data in 2018.
extrapolated_weights.filelist <- list.files("data/",
                       include.dirs = FALSE,
                       full.names = TRUE,
                       pattern = 'extrapolated_weights_data_[0-9]{4}.csv')[1:3]# get files for 2016-2018.

extrapolated.weights.data <- do.call(rbind, lapply(extrapolated_weights.filelist, read.csv))
extrapolated.weights.data <- replace.missing(extrapolated.weights.data)
extrapolated.weights <- extrapolated.weights.data[, c("plus_5_weight")]


# adding updated weights to MICE set. 
mice_set.subset.2011_2013.updated_weights <- mice.long[which(mice.long$time %in% c(2011, 2012, 2013)), ]
mice_set.subset.2011_2013.updated_weights$pidp <- mice.pidp
mice_set.subset.2011_2013.updated_weights$hidp <- mice.hidp
mice_set.subset.2011_2013.updated_weights$weight <- extrapolated.weights
mice_set.subset.2011_2013.updated_weights$time <- mice.time
mice_set.subset.2011_2013.updated_weights <- as.mids2(mice_set.subset.2011_2013.updated_weights)

```

```{r weighted_regressions}

# weighted regression for 2016-2018 using 2011-2013 models and projected weights
sf12.lm.weighted.2013 <- pool(with(mice_set.subset.2011_2013.updated_weights, lm(as.formula(mice_formula_string), weights = weight)))



#Â  weighted regression for 2016-2018 using 2018 data.
sf12.lm.weighted.2018 <- pool(with(mice_set.subset.2016_2018, lm(as.formula(mice_formula_string), weights = weight)))

# compare coefficients/diagnostics?

#todo test.

texreg_file <- paste0(save.path, 'projected_weights_coefficients.txt')
tex_label <- paste0("table: sf12_projected_weights_coefficients") 
tex_headers <- c(texreg::names2latex("SF_12 2018 With 2013 Extrapolated Weights"), texreg::names2latex("SF_12 2018 With Weights"))
tex_caption <- texreg::names2latex(get_tex_table_caption("SF_12", "projectied_ols"))    
texreg(list(sf12.lm.weighted.2013,sf12.lm.weighted.2018), # what model to save coefs for. 
       file=texreg_file,  # where to save.
       custom.model.names = tex_headers, # title of table.
       stars = c(0.001, 0.01, 0.05), # p-value significance symbols. 
       digits=4, # p values significant figures.
       caption=tex_caption, # \caption command option. 
       label = tex_label, # \label command option. 
       dcolumn=T,# nice column alignment. 
       booktabs=T, # nice hlines. (recommended)
       tabular=T,# tabular env.
       single.row = T, # nicer one row formatting.
       longtable=T, #Â allows tables to wrap over pages
       use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
       fontsize='tiny') # tiny font
```

## HETEROGENEITY ###############################################################


```{r "glmm"}

# yoink transition model function pre processing
reflect <- T
yeo_johnson <- F
include_weights <- T
depend <- "SF_12"
dependent_data <- complete(mice_set.subset)$SF_12

glmm.mice.long.subset <- complete(mice_set.subset, "long", include=T)

if (reflect) {
    max_value <- nanmax(mice.data[[depend]])
    glmm.mice.long.subset[, c(depend)] <- max_value - glmm.mice.long.subset[, c(depend)] + 0.001
  }
if (yeo_johnson)
{
  yj <- yeojohnson(glmm.mice.long.subset[["SF_12"]])
  glmm.mice.long.subset[["SF_12"]] <- predict(yj)
  
  min_value <- nanmin(glmm.mice.long.subset [[depend]])
  glmm.mice.long.subset[[depend]] <- glmm.mice.long.subset[[depend]] - min_value + 0.001
}

glmm.mice.long.subset <- glmm.mice.long.subset %>%
           group_by(pidp) %>%
            #mutate(diff = .data[[dependent]] - lag(.data[[dependent]], order_by = time)) %>%
            mutate(last = lag(.data[["SF_12"]], order_by = time)) %>%
            rename_with(.fn = ~paste0('SF_12_', .), .cols = last)  # add the dependent as prefix to the calculated diff
#glmm.mice.long.subset <- glmm.mice.long.subset[!is.na(glmm.mice.long.subset$SF_12_last), ]
glmm.mice.long.subset <- glmm.mice.long.subset[glmm.mice.long.subset$time %in% c(2011, 2012, 2013), ]
glmm.mice.long.subset$.imp <- as.numeric(glmm.mice.long.subset$.imp)
glmm.mice.long.subset <- as.data.frame(glmm.mice.long.subset)
glmm.mice.set <- as.mids2(glmm.mice.long.subset)

asd <- "SF_12_last +"
glmm_model_formula_string <- "I(log(SF_12+10)) ~ SF_12_last +
                  factor(sex) + 
                  relevel(factor(ethnicity), ref='WBI') + 
                  scale(age) + 
                  factor(education_state) + 
                  factor(labour_state) + 
                  relevel(factor(NSSEC), ref=1) +
                  relevel(factor(region), ref='London') +
                  scale(hh_income) + 
                  scale(I(hh_income**2)) +
                  factor(housing_quality) +
                  factor(neighbourhood_safety) +
                  factor(loneliness) + 
                  nutrition_quality + 
                  ncigs + time +
                  (1|pidp)"

sf12.glmm.model <- with(glmm.mice.set, glmer(glmm_model_formula_string,  
               nAGQ=0, # fast but inaccurate optimiser. nAGQ=1 takes forever..
               family=Gamma(link='log')#, weights=weight# gamma family with log link.
               ))

sf12.glmm.pool <- pool(sf12.glmm.model)

# mice objects dont go in forest plot annoyingly. move coefficients over to a
# dummy lm that sjPlot::plot_models can read.
mice.glmm.object <- sf12.glmm.model$analyses[[1]]
mice.glmm.object@beta <- sf12.glmm.pool$pooled$estimate
#attr(mice.glmm.object, "beta") <- sf12.glmm.pool$estimate
#mice.glmm.object@ <- sf12.glmm.pool$std.error
#mice.glmm.object$coefficients[,3] <- sf12.glmm.pool$statistic
#mice.glmm.object$coefficients[,4] <- sf12.glmm.pool$p.value


print(r2_nakagawa(sf12.glmm.model$analyses[[1]]))

#save(sf12.glmm.model, file = paste0(save.path,"sf12_glmm.RData"))


write_coefs <- T
if (write_coefs)
{
  texreg_file <- paste0(save.path, 'SF_12_GLMM_coefficients.txt')
  tex_label <- paste0("table: GLMM_SF_12_coefficients") 
  tex_headers <- c(texreg::names2latex("SF_12 GLMM"))
  tex_caption <- texreg::names2latex(get_tex_table_caption("SF_12", "glmm"))    
  texreg(sf12.glmm.pool, # what model to save coefs for. 
         file=texreg_file,  # where to save.
         custom.model.names = tex_headers, # title of table.
         stars = c(0.001, 0.01, 0.05), # p-value significance symbols. 
         digits=4, # p values significant figures.
         caption=tex_caption, # \caption command option. 
         label = tex_label, # \label command option. 
         dcolumn=T,# nice column alignment. 
         booktabs=T, # nice hlines. (recommended)
         tabular=T,# tabular env.
         single.row = T, # nicer one row formatting.
         longtable=T, #Â allows tables to wrap over pages
         use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
         fontsize='tiny') # tiny font
}

# + rnorm(nrow(complete(glmm.mice.set ,1)), 0,0.75)
if (yeo_johnson == T) {
  glmm.fitted <- (max_value - predict(yj, predict(mice.glmm.object, type='response') + min_value #+rnorm(predict(mice.glmm.object, type='response'),0,0.2)
                                    , inverse=T))#
} else {
  #glmm.fitted <-  max_value - predict(mice.glmm.object, type='response')
  glmm.fitted <-  max_value - (exp(predict(mice.glmm.object, type='response')) - 10)

}


#glmm.fitted <- (max_value - predict(mice.glmm.object, type='response') + min_value + rnorm(nrow(glmm.mice.long.subset), 0, 1))
#glmm.mean <- mean(glmm.fitted)
#glmm.sd <- sd(glmm.fitted)
#glmm.fitted <- glmm.fitted * (glmm.sd/sd(raw.data$SF_12))
#glmm.fitted <- glmm.fitted - (glmm.mean*(glmm.sd/sd(raw.data$SF_12)-1))
#glmm.fitted <- trunc(glmm.fitted, 0 , 100) #+ rnorm(length(glmm.fitted),0,2)

qq_plot(scale(residuals(mice.glmm.object, type='pearson')), paste0(save.path, "glmm_qq.pdf"))
qq_plot(scale(residuals(mice.glmm.object, type='deviance')), paste0(save.path, "glmm_qq.pdf"))

residual_density_plot(res=residuals(mice.glmm.object) , file_name=paste0(save.path, "glmm_residual_density.pdf"), guide="normal")

squareRootRes <- sqrt(residuals(mice.glmm.object, type='pearson')**2)
#squareRootRes <- residuals(mice.glmm.object, type='pearson')

fitted_residuals <- as.data.frame(cbind(glmm.fitted, squareRootRes))
colnames(fitted_residuals) <- c("fitted", "sqrt_residuals")
fitted_residual_plot(fitted_residuals, paste0(save.path, "glmm_scale_location_plot.pdf"))


#TODO change cofficient and std scaling.
# - (exp coefficients. - 1)??
# start pm standard error and take above exponential formula?. 
# test exp argument in plot_model

#mice.glmm.object@beta <- mice.glmm.object@beta
  
#mice.glmm.object@beta <- -mice.glmm.object@beta 
gamma_forest_plot(mice.glmm.object, paste0(save.path, "glmm_forest.pdf"))
log_forest_plot(mice.glmm.object, paste0(save.path, "glmm_forest.pdf"))
#mice.glmm.object@beta <- -mice.glmm.object@beta 

```


```{r glmm_handover_data}
# load raw composite data for glmm handovers.
crossval.glmm.data <- replace.missing(complete(mice_set.full, 1)[, append(variables, c("time", 'pidp', 'hidp', 'weight'))])
crossval.glmm.data <- crossval.glmm.data[which(crossval.glmm.data$time>=2013),]
crossval.glmm.data <- drop_na(crossval.glmm.data)
```

```{r glmm_handovers}
cppFunction('NumericVector rcpp_clip( NumericVector x, double a, double b){
    return clamp( a, x, b ) ;
}')


start.data <- complete(glmm.mice.set, 1)
start.data <- start.data[which(start.data$time==2013),]
start.data$SF_12 <- max_value - start.data$SF_12
#start.data$SF_12 <- crossval.glmm.data[which(crossval.glmm.data$time==2013),]$SF_12
if (yeo_johnson == T) {
start.data$SF_12 <- max_value - predict(yj, start.data$SF_12 +min_value, inverse=T)
start.data <- drop_na(start.data)
} #else {
  #start.data$SF_12 <- start.data$SF_12
  #start.data$SF_12 <- max_value - start.data$SF_12
#}
#start.data$SF_12_last <- max_value - start.data$SF_12_last
handover.data <- start.data
rolling.data <- start.data

for (i in 1:8){
  if (yeo_johnson == T) {
      #rolling.data$SF_12 <- predict(mice.glmm.object, rolling.data, type='response',allow.new.levels=T)
      #rolling.data$SF_12 <- max_value - rolling_data$SF_12
      rolling.data$SF_12 <- exp(predict(mice.glmm.object, rolling.data, type='response', allow.new.levels=T))-10
      rolling.data$SF_12_last <- rolling.data$SF_12                           
      #rolling.data$SF_12 <- max_value - predict(yj,  rolling.data$SF_12 +min_value+ rnorm(nrow(rolling.data), 0, 0.3), inverse=T)
      rolling.data$SF_12 <- max_value - predict(yj,  rolling.data$SF_12 +min_value+ rnorm(nrow(rolling.data), 0, 0.3), inverse=T)
  }
  else {
    #rolling.data$SF_12 <- max_value - predict(mice.glmm.object, rolling.data, type='response',allow.new.levels=T) + rnorm(nrow(rolling.data), 0, 1)
    #rolling.data$SF_12 <- max_value - rolling.data$SF_12
    rolling.data$SF_12 <- (exp(predict(mice.glmm.object, rolling.data, type='response',allow.new.levels=T))-10) + rnorm(nrow(rolling.data), 0, 0.01)
    
    rd.mean <- median(rolling.data$SF_12, na.rm=T)
    rolling.data$SF_12 <- rolling.data$SF_12 * 1.05
    rolling.data$SF_12 <- rolling.data$SF_12 - ((1.05-1)*rd.mean)
    rolling.data$SF_12_last <- rolling.data$SF_12
    
  }
  rolling.data$SF_12 <- max_value - rolling.data$SF_12
  rolling.data$SF_12 <- rcpp_clip(rolling.data$SF_12, 0, 100)
  rolling.data[, 'time'] <- rolling.data[, 'time'] +1
  handover.data <- rbind(handover.data, rolling.data)
  #rolling.data$SF_12 <- max_value - predict(yj,  rolling.data$SF_12 +min_value+ rnorm(nrow(rolling.data), 0, 0.3), inverse=T))
}

handover_boxplots(crossval.glmm.data, handover.data, "SF_12", save.path, "glmm_SF12_boxplot")
density_ridges(crossval.glmm.data, "SF_12", save=TRUE, save.path=save.path, filename.tag = "glmm_raw_ridges")
density_ridges(handover.data, "SF_12", save=TRUE, save.path=save.path, filename.tag = "glmm_handover_ridges")

```

```{r glmm_crossval}

fit.glmm.to.each.fold <- function(mice.fold.data) {
  sf12.glmm.model <- with(mice.fold.data, glmer(glmm_model_formula_string,  
               nAGQ=0, # fast but inaccurate optimiser. nAGQ=1 takes forever..
               family=Gamma(link='log')#, weights=weight# gamma family with log link.
               ))
  
  sf12.glmm.pool <- pool(sf12.glmm.model)
  
  # mice objects dont go in forest plot annoyingly. move coefficients over to a
  # dummy lm that sjPlot::plot_models can read.
  mice.glmm.object <- sf12.glmm.model$analyses[[1]]
  mice.glmm.object@beta <- sf12.glmm.pool$pooled$estimate
  #attr(mice.glmm.object, "beta") <- sf12.glmm.pool$estimate
  #mice.glmm.object@ <- sf12.glmm.pool$std.error
  #mice.glmm.object$coefficients[,3] <- sf12.glmm.pool$statistic
  #mice.glmm.object$coefficients[,4] <- sf12.glmm.pool$p.value
  print(r2_nakagawa(sf12.glmm.model$analyses[[1]]))
return(mice.glmm.object)
}

#split mice sets into 5 based on pidps
pidps <- complete(mice_set.subset, 1)$pidp
pidp_chunks <- groupKFold(pidps, k=5)
pidp_chunks1 <- unique(pidps[pidp_chunks$Fold1])
pidp_chunks2 <- unique(pidps[pidp_chunks$Fold2])
pidp_chunks3 <- unique(pidps[pidp_chunks$Fold3])
pidp_chunks4 <- unique(pidps[pidp_chunks$Fold4])
pidp_chunks5 <- unique(pidps[pidp_chunks$Fold5])
# subset mice long based on these chunks. convert back to mids.

# taking desired subset of pidps for each fold
glmm.mice.long.subset.fold1 <- filter(glmm.mice.long.subset, !pidp %in% pidp_chunks1)
glmm.mice.long.subset.fold2 <- filter(glmm.mice.long.subset, !pidp %in% pidp_chunks2)
glmm.mice.long.subset.fold3 <- filter(glmm.mice.long.subset, !pidp %in% pidp_chunks3)
glmm.mice.long.subset.fold4 <- filter(glmm.mice.long.subset, !pidp %in% pidp_chunks4)
glmm.mice.long.subset.fold5 <- filter(glmm.mice.long.subset, !pidp %in% pidp_chunks5)

# convert back to mice objects
glmm.mice.set.fold1 <- as.mids2(glmm.mice.long.subset.fold1)
glmm.mice.set.fold2 <- as.mids2(glmm.mice.long.subset.fold2)
glmm.mice.set.fold3 <- as.mids2(glmm.mice.long.subset.fold3)
glmm.mice.set.fold4 <- as.mids2(glmm.mice.long.subset.fold4)
glmm.mice.set.fold5 <- as.mids2(glmm.mice.long.subset.fold5)

# fit glmms.
sf12.glmm.fold1 <- fit.glmm.to.each.fold(glmm.mice.set.fold1)
sf12.glmm.fold2 <- fit.glmm.to.each.fold(glmm.mice.set.fold2)
sf12.glmm.fold3 <- fit.glmm.to.each.fold(glmm.mice.set.fold3)
sf12.glmm.fold4 <- fit.glmm.to.each.fold(glmm.mice.set.fold4)
sf12.glmm.fold5 <- fit.glmm.to.each.fold(glmm.mice.set.fold5)

# get training sts.

# taking desired subset of pidps for each fold
glmm.mice.long.subset.test1 <- drop_na(filter(glmm.mice.long.subset, pidp %in% pidp_chunks1))
glmm.mice.long.subset.test2 <- drop_na(filter(glmm.mice.long.subset, pidp %in% pidp_chunks2))
glmm.mice.long.subset.test3 <- drop_na(filter(glmm.mice.long.subset, pidp %in% pidp_chunks3))
glmm.mice.long.subset.test4 <- drop_na(filter(glmm.mice.long.subset, pidp %in% pidp_chunks4))
glmm.mice.long.subset.test5 <- drop_na(filter(glmm.mice.long.subset, pidp %in% pidp_chunks5))

#get RMSE. 

rmse2 <- function(preds, obs){
  obs_minus_preds_squared <- (preds - obs)**2
  out <- sqrt(sum(obs_minus_preds_squared/nrow(glmm.mice.long.subset.test1)))
  return (out)
}

RMSE1 <- rmse2(predict(sf12.glmm.fold1, glmm.mice.long.subset.test1, type='response', allow.new.levels=T),
               log(glmm.mice.long.subset.test1$SF_12+10))
RMSE2 <- rmse2(predict(sf12.glmm.fold2, glmm.mice.long.subset.test2, type='response', allow.new.levels=T),
               log(glmm.mice.long.subset.test2$SF_12+10))
RMSE3 <- rmse2(predict(sf12.glmm.fold3, glmm.mice.long.subset.test3, type='response', allow.new.levels=T),
               log(glmm.mice.long.subset.test3$SF_12+10))
RMSE4 <- rmse2(predict(sf12.glmm.fold4, glmm.mice.long.subset.test4, type='response', allow.new.levels=T),
               log(glmm.mice.long.subset.test4$SF_12+10))
RMSE5 <- rmse2(predict(sf12.glmm.fold5, glmm.mice.long.subset.test5, type='response', allow.new.levels=T),
               log(glmm.mice.long.subset.test5$SF_12+10))
print(RMSE1)
print(RMSE2)
print(RMSE3)
print(RMSE4)
print(RMSE5)
rmse_glmm_values <- c(RMSE1, RMSE2, RMSE3, RMSE4, RMSE5)
mean(rmse_glmm_values)
var(rmse_glmm_values)
# about 0.15. still improves over mice
```
