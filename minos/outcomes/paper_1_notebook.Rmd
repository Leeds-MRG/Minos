---
title: "Paper 1 Notebook"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r "preamble"}
source("minos/transitions/utils.R")
source("minos/transitions/transition_model_functions.R")
source("minos/transitions/paper_1_plots.R")
library(dplyr)
library(texreg)
library(lme4)
library(glmnet)
library(mice)
library(sjPlot)
library(visreg)
library(ggplot2)
library(ggpattern)
library(VIM)
library(caret)
library(tidyverse)
library(performance)
library(broom.mixed)
library(ggridges)
library(ggmice)
library(MASS)
save.path <- "minos/outcomes/paper1_plots/"
raw.data.dir <- "data/raw_US/"
mice.data.dir <- "data/composite_US/"
final.data.dir <- mice.data.dir
```


##############################
# baseline and presentation ##
##############################


```{r "raw_data_processing"}

# get raw data file names from 2011-2013.
filelist <- list.files(raw.data.dir,
                       include.dirs = FALSE,
                       full.names = TRUE,
                       pattern = '[0-9]{4}_US_cohort.csv')[21:23] # get files for 2011-2013.
# load raw data.
raw.data <- do.call(rbind, lapply(filelist, read.csv))

# baseline OLS model formula. 
raw_model_formula_string <- "SF_12 ~ factor(sex) + 
                  relevel(factor(ethnicity), ref='WBI') + 
                  scale(age) + 
                  factor(education_state) + 
                  factor(labour_state_raw) + 
                  relevel(factor(NSSEC), ref=1) +
                  relevel(factor(region), ref='London') +
                  scale(hh_netinc)"

# Calculate required variables for regression to run. 
raw_model_formula <- as.formula(raw_model_formula_string)
variables <- all.vars(raw_model_formula)

# get only needed variables and replace missing codes with NA.
raw.data.colnames <- colnames(raw.data)
raw.data.colnames[which( colnames(raw.data)=="job_sec" )] <- "NSSEC"
colnames(raw.data) <- raw.data.colnames
raw.data <- raw.data[, append(variables, c("time", 'pidp', 'weight'))]
raw.data <- replace.missing(raw.data)


raw.data <- drop_na(raw.data)

# get raw data file names.
full.raw.filelist <- list.files(raw.data.dir,
                       include.dirs = FALSE,
                       full.names = TRUE,
                       pattern = '[0-9]{4}_US_cohort.csv')[21:30] # get files for 2011-2013.
# load raw data.
full.raw.data <- do.call(rbind, lapply(full.raw.filelist, read.csv))
full.raw.data.colnames <- colnames(full.raw.data)
full.raw.data.colnames[which( colnames(full.raw.data)=="job_sec" )] <- "NSSEC"
colnames(full.raw.data) <- full.raw.data.colnames
# get only needed variables and replace missing codes with NA.
full.raw.data <- full.raw.data[, append(variables, c("time", 'pidp', 'weight'))]
full.raw.data <- replace.missing(full.raw.data)
```


```{r "OLS"}

# calculate baseline OLS model.
sf12.lm <- lm(raw_model_formula_string,
              data= raw.data)
# print summary statistics
print(summary(sf12.lm))

# create save.path if it doesn't exist and save OLS coefficients as a latex table there. 
create.if.not.exists(save.path)
write_coefs <- T
if (write_coefs)
{
  texreg_file <- paste0(save.path, 'SF12_OLS_coefficients.txt')
  tex_label <- paste0("table: baseline_OLS_coefficients") 
  tex_headers <- c(texreg::names2latex("Baseline SF_12 OLS"))
  tex_caption <- texreg::names2latex(get_tex_table_caption("SF_12", "ols"))    
  texreg(sf12.lm, # what model to save coefs for. 
         file=texreg_file,  # where to save.
         custom.model.names = tex_headers, # title of table.
         stars = c(0.001, 0.01, 0.05), # p-value significance symbols. 
         digits=4, # p values significant figures.
         caption=tex_caption, # \caption command option. 
         label = tex_label, # \label command option. 
         dcolumn=T,# nice column alignment. 
         booktabs=T, # nice hlines. (recommended)
         tabular=T,# tabular env.
         single.row = T, # nicer one row formatting.
         longtable=T, # allows tables to wrap over pages
         use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
         fontsize='small') # small font
}


# diagnostic plots for OLS presentation. 
forest_plot_lm(sf12.lm, paste0(save.path, "presentation_forest.pdf"))
qq_plot(resid(sf12.lm), paste0(save.path, "presentation_qq.pdf"))
residual_density_plot(res=resid(sf12.lm), file_name=paste0(save.path, "presentation_residual_density.pdf"), guide="normal")

squareRootRes <- sqrt(abs(scale(resid(sf12.lm))))
fitted_residuals <- as.data.frame(cbind(fitted(sf12.lm), squareRootRes))
colnames(fitted_residuals) <- c("fitted", "sqrt_residuals")
fitted_residual_plot(fitted_residuals, paste0(save.path, "presentation_scale_location_plot.pdf"))

# raw data handovers from 2011-2020. 

start.data <- raw.data[which(raw.data$time==2013),]
handover.data <- start.data[, c("pidp", "SF_12", "time")]
for (i in 1:7){
  start.data$SF_12 <- predict(sf12.lm, start.data)
  start.data[, 'time'] <- start.data[, 'time'] +1
  handover.data <- rbind(handover.data, start.data[, c("pidp", "SF_12", "time")])
}


handover_boxplots(full.raw.data, handover.data, "SF_12", save.path, "ols_SF12_boxplot")
density_ridges(full.raw.data, "SF_12", save=TRUE, save.path=save.path, filename.tag = "ols_raw_ridges")
density_ridges(handover.data, "SF_12", save=TRUE, save.path=save.path, filename.tag = "ols_handover_ridges")

# remove raw data to prevent lag. 
#rm(raw.data)
#rm(full.raw.data)
```



##################################
# missingness ####################
##################################

```{r}
# load in all 2009-2020 datasets
mice.filelist <- list.files(mice.data.dir,
                       include.dirs = FALSE,
                       full.names = TRUE,
                       pattern = '[0-9]{4}_US_cohort.csv')
mice.data <- do.call(rbind, lapply(mice.filelist, read.csv))

mice.data.colnames <- colnames(mice.data)
mice.data.colnames[which(colnames(mice.data)=="job_sec" )] <- "NSSEC"
colnames(mice.data) <- mice.data.colnames

# missingness MICE model formula
mice_formula_string <- "SF_12 ~ 
                        factor(sex) + 
                        relevel(factor(ethnicity), ref='WBI') + 
                        scale(age) + 
                        factor(education_state) + 
                        factor(S7_labour_state) + 
                        relevel(factor(NSSEC), ref=1) +
                        relevel(factor(region), ref='London') +
                        scale(hh_income) + 
                        scale(I(hh_income**2)) +
                        factor(housing_quality) +
                        factor(neighbourhood_safety) + 
                        factor(loneliness) +
                        ncigs +
                        nutrition_quality"

mice_model_formula <- as.formula(mice_formula_string)
variables <- all.vars(mice_model_formula)

# get required variables and replace missing value codes.
mice.data <- replace.missing(mice.data)

# preserving key columns that aren't imputed for later. cant be included. in imputation set due to perfect seperation. 
mice.pidp <- mice.data[which(mice.data$time %in% c(2011, 2012, 2013)), "pidp"]
mice.time <- mice.data[which(mice.data$time %in% c(2011, 2012, 2013)), "time"]
mice.weights <- mice.data[which(mice.data$time %in% c(2011, 2012, 2013)), "weight"]

mice.2018.pidp <- mice.data[which(mice.data$time %in% c(2016, 2017, 2018)), "pidp"]
mice.2018.time <- mice.data[which(mice.data$time %in% c(2016, 2017, 2018)), "time"]
mice.2018.weights <- mice.data[which(mice.data$time %in% c(2016, 2017, 2018)), "weight"]
```


```{r MICE}

#getting MICE data for 2011-2020. imputing loneliness, housing, neighbourhood. 
# set up MICE and cache data
# plots of missingness pre and post raw US
# figures of convergence and difference in distribution.


imp_columns <- c("SF_12",
                 'sex',
                 "NSSEC",
                 "education_state",
                 "S7_labour_state", 
                 "region", 
                 "ethnicity", 
                 "age", 
                 "time", 
                 "hh_income",
                 "housing_quality",
                 "neighbourhood_safety",
                 "loneliness",
                 "ncigs",
                 'nutrition_quality'
)

method <- c("pmm",
            'pmm',
            'pmm',
            'pmm',#'polr',
            'pmm',
            'pmm', #'polr',
            'pmm',
            'pmm', #'polr', #'pmm',
            'pmm',
            'pmm',
            'pmm',
            'pmm',
            'pmm',
            'pmm',
            "pmm",
            "pmm")

# structure plots for adding in auxliary variables

#pdf("papers/phd1/plots/total_missingness_structure2.pdf")
#aggr(subset(final.data[,reg_columns], select=-c(y)), sortVars=T,  oma=c(8,4,4,4), numbers=T, cex.axis=1.0, col = c(blue, orange), prop=F, combined=T, cex.numbers=0.5)
#dev.off()

aggr_columns <- c("SF_12",
                 "NSSEC",
                 "education_state",
                 "S7_labour_state", 
                 "ethnicity", 
                 "hh_income",
                 "neighbourhood_safety",
                 "loneliness",
                 "ncigs",
                 'nutrition_quality'
)
# initial missingness structure for 2011-2013 US data.
pdf(paste0(save.path, "total_missingness_structure1.pdf"))
aggr(mice.data[,aggr_columns], sortVars=T, prop=T, combined=F,varheight=T, oma=c(10,5,1,2), gap=0)
dev.off()



mice_columns <- c("age", 
                  "region", 
                  #"heating", 
                  "NSSEC", 
                  "ncigs",
                  "education_state",            
                  "ethnicity",
                  "loneliness",
                  "sex", 
                  "SF_12",
                  #"SF_12p",
                  #"smoker",
                  "nkids",       
                  "behind_on_bills",
                  "financial_situation",
                  "future_financial_situation",
                  "likely_move",
                  "ghq_depression",
                  "ghq_happiness",
                  "clinical_depression", 
                  "scsf1",
                  "health_limits_social",
                  #"hhsize",
                  #"housing_tenure",
                  #"urban", 
                  "housing_quality",
                  "hh_income",
                  "neighbourhood_safety",
                  "S7_labour_state",
                  #"yearly_energy",
                  "nutrition_quality"
                  #"hh_comp", 
                  #"marital_status"
)


mice.data$ethnicity <- factor(mice.data$ethnicity)
mice.data$S7_labour_state <- factor(mice.data$S7_labour_state)
mice.data$region <- factor(mice.data$region)
mice.data$loneliness <- factor(mice.data$loneliness)
#mice.data$heating <- factor(mice.data$heating)
#mice.data$job_sec <- factor(mice.data$job_sec)
#mice.data$education_state <- factor(mice.data$education_state)
#mice.data$sex <- factor(mice.data$sex)
#mice.data$smoker <- factor(mice.data$smoker)
#mice.data$behind_on_bills <- factor(mice.data$behind_on_bills)
#mice.data$ghq_depression <- factor(mice.data$ghq_depression)
#mice.data$ghq_happiness <- factor(mice.data$ghq_happiness)
#mice.data$clinical_depression <- factor(mice.data$clinical_depression)
#mice.data$scsf1 <- factor(mice.data$scsf1)
#mice.data$health_limits_social <- factor(mice.data$ghq_depression)
#mice.data$housing_tenure <- factor(mice.data$housing_tenure)
#mice.data$urban <- factor(mice.data$urban)
#mice.data$marital_status <- factor(mice.data$marital_status)





load_cache <- T
if (load_cache) {
  mice_set <- readRDS("data/transitions/MICE_set.rds")
} else {
  n_iter <- 30
  max_iter <- 10
  ignore_cols = c("birth_year")
  # future mice is parallelised version of MICE.
  mice_set <- mice(data = mice.data[, imp_columns],
                   m = n_iter, maxit = max_iter,
                   remove.collinear=T)
  
  #mice_set <- with_progress(futuremice(data = mice.data[, mice_columns], #method=method,
  #                m = n_iter, maxit = max_iter,
  #                 remove.collinear=T, quiet=F,
  #                 progressor = progressr::handlers("progress")))
  saveRDS(mice_set, "data/transitions/MICE_set.rds")
}

```

```{r mice_output}

# only looking at 2011-2013 subset of data. convert to data frame, subset, and back to MICE mids. 
# also adding variables that can't be imputed back in. pidp time weight.
mice.long <- complete(mice_set, action = "long", include=T)
#mice.long.subset <- mice.long[which(mice.long$time %in% c(2011, 2012, 2013)), ]

mice.long$pidp <- mice.data$pidp
mice.long$weight <- mice.data$weight
mice.long$time <- mice.data$time
mice.long.colnames <- colnames(mice.long)
mice.long.colnames[which( colnames(mice.long)=="job_sec" )] <- "NSSEC"
colnames(mice.long) <- mice.long.colnames

mice_set.full <- as.mids(mice.long)

mice.long.subset <- mice.long[which(mice.long$time %in% c(2011, 2012, 2013)), ]
mice_set.subset <- as.mids(mice.long.subset)


# convergence plots needs to be done on full mice subset. 
pdf(paste0(paste0(save.path,"ols_mice_convergence.pdf")))
#print(plot(mice_set, SF_12 = SF_12 ~ .it | .ms))
plot_trace(mice_set, "SF_12") + theme(legend.position="none")
dev.off()

# pooling OLS estimate together. 
mice.sf12.lm <- with(mice_set.subset, lm(as.formula(mice_formula_string)))
final.pool<- pool(mice.sf12.lm)

# summary stats for final pool. 
pooled_lm <- mice.sf12.lm$analyses[[1]]
pool.sum <- summary(final.pool)
pooled_lm$coefficients = pool.sum$estimate
mice.preds<- predict(pooled_lm)
pool.r.squared(final.pool)

# mice objects dont go in forest plot annoyingly. move coefficients over to a
# dummy lm that sjPlot::plot_models can read.
mice.lm.object <- summary(lm(mice_formula_string, data = complete(mice_set.subset)))
mice.lm.object$coefficients[,1] <- pool.sum$estimate
mice.lm.object$coefficients[,2] <- pool.sum$std.error
mice.lm.object$coefficients[,3] <- pool.sum$statistic
mice.lm.object$coefficients[,4] <- pool.sum$p.value

# making density plot. 
res <- as.data.frame(predict(pooled_lm))
real <- as.data.frame(mice.data$SF_12)
res$type <- c("Predicted")
real$type <- c("Real")
colnames(res) <- c("SF12", 'type')
colnames(real) <- c("SF12", 'type')
hist.data <- rbind(res,real)
hist.data <- tidyr::drop_na(hist.data)

res <- as.data.frame(resid(pooled_lm))
residual_density_plot(res, paste0(save.path,'mice_ols_densities.pdf'), guide='normal')

# coefficient forest plot. 
forest_plot(mice.lm.object, paste0(save.path,'mice_SF12_forest.pdf'))
qq_plot(resid(mice.lm.object), paste0(save.path, "mice_qq.pdf"))


# writing coefficients table for MICE. 
# is there a version for pool table?
write_coefs <- T
if (write_coefs)
{
  texreg_file <- paste0(save.path, 'SF12_MICE_OLS_coefficients.txt')
  tex_label <- paste0("table: MICE_OLS_coefficients") 
  tex_headers <- c(texreg::names2latex("MICE SF_12 OLS"))
  tex_caption <- texreg::names2latex(get_tex_table_caption("SF_12", "ols"))    
  texreg(mice.lm.object, # what model to save coefs for. 
         file=texreg_file,  # where to save.
         custom.model.names = tex_headers, # title of table.
         stars = c(0.001, 0.01, 0.05), # p-value significance symbols. 
         digits=4, # p values significant figures.
         caption=tex_caption, # \caption command option. 
         label = tex_label, # \label command option. 
         dcolumn=T,# nice column alignment. 
         booktabs=T, # nice hlines. (recommended)
         tabular=T,# tabular env.
         single.row = T, # nicer one row formatting.
         longtable=T, # allows tables to wrap over pages
         use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
         fontsize='small') # small font
  
  # same again for MICE pool. 
  texreg_file <- paste0(save.path, 'SF12_MICE_pool_OLS_coefficients.txt')
  tex_label <- paste0("table: MICE_pool_OLS_coefficients") 
  tex_headers <- c(texreg::names2latex("MICE SF_12 OLS Pool"))
  tex_caption <- texreg::names2latex(get_tex_table_caption("SF_12", "ols"))    
  texreg(final.pool, # what model to save coefs for. 
         file=texreg_file,  # where to save.
         custom.model.names = tex_headers, # title of table.
         stars = c(0.001, 0.01, 0.05), # p-value significance symbols. 
         digits=4, # p values significant figures.
         caption=tex_caption, # \caption command option. 
         label = tex_label, # \label command option. 
         dcolumn=T,# nice column alignment. 
         booktabs=T, # nice hlines. (recommended)
         tabular=T,# tabular env.
         single.row = T, # nicer one row formatting.
         longtable=T, # allows tables to wrap over pages
         use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
         fontsize='small') # small font
}

#screenreg final.pool
```


############################
# validation ###############
############################

```{r cross validated nowcasting}
# split data into five
# transition models
# compare coefficients in plots. 

# training the model by assigning sales column
# as target variable and rest other column
# as independent variable

trControl <- trainControl(method = "cv", number=5, returnData=F, trim=T, verboseIter = TRUE)

cross.val.sf12.model <- train(as.formula(mice_formula_string), data = complete(mice_set.subset, 1, include=F),
               method = "lm",
               trControl = trControl)

# come back to this. 
#with(mice_set.subset,  train(as.formula(mice_formula_string),
#               method = "lm",
#               trControl = trControl))
 
# printing model performance metrics
# along with other details
#print(summary(cross.val.sf12.model))

write_coefs <- T
if (write_coefs)
{
  texreg_file <- paste0(save.path, 'SF12_cross_val_OLS_coefficients.txt')
  tex_label <- paste0("table: ols_cross_val_coefficients") 
  tex_headers <- c(texreg::names2latex("5-Fold Cross Validated SF_12 OLS"))
  tex_caption <- texreg::names2latex(get_tex_table_caption("cv_SF_12", "ols"))    
  texreg(summary(cross.val.sf12.model), # what model to save coefs for. 
         file=texreg_file,  # where to save.
         custom.model.names = tex_headers, # title of table.
         stars = c(0.001, 0.01, 0.05), # p-value significance symbols. 
         digits=4, # p values significant figures.
         caption=tex_caption, # \caption command option. 
         label = tex_label, # \label command option. 
         dcolumn=T,# nice column alignment. 
         booktabs=T, # nice hlines. (recommended)
         tabular=T,# tabular env.
         single.row = T, # nicer one row formatting.
         longtable=T, # allows tables to wrap over pages
         use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
         fontsize='small') # small font
}
```



```{r cross_val_handovers}
# boxplots for handovers
#.estimating from 2014-2020.
# get data for 2013- 2020
# run 2013 pop through transition probability model a few times. 
# profit. 
# run it through model a few times
# compare with real data in boxplots and ridgelines. 

crossval.mice.data <- complete(mice_set.full, 1, include = F)
crossval.mice.data <- replace.missing(crossval.mice.data)
crossval.mice.data <- drop_na(crossval.mice.data)
```


```{r mice_handovers}
start.data <- crossval.mice.data[which(crossval.mice.data$time==2013),]
rolling.data <- start.data[, c("pidp", "SF_12", "time")]
handover.data <- rolling.data
for (i in 1:7){
  rolling.data$SF_12 <- predict(pooled_lm, start.data)
  start.data$SF_12 <- rolling.data$SF_12
  rolling.data[, 'time'] <- rolling.data[, 'time'] +1
  handover.data <- rbind(handover.data, rolling.data)
}


handover_boxplots(crossval.mice.data, handover.data, "SF_12", save.path, "mice_SF12_boxplots")
density_ridges(crossval.mice.data, "SF_12", save=TRUE, save.path=save.path, filename.tag = "mice_raw_ridges")
density_ridges(handover.data, "SF_12", save=TRUE, save.path=save.path, filename.tag = "mice_validation_ridges")

```


```{r cross_val_handovers}
start.data <- crossval.mice.data[which(crossval.mice.data$time==2013),]
rolling.data <- start.data[, c("pidp", "SF_12", "time")]
handover.data <- rolling.data

for (i in 1:7){
  rolling.data$SF_12 <- predict(cross.val.sf12.model, start.data)
  start.data$SF_12 <- rolling.data$SF_12
  rolling.data[, 'time'] <- rolling.data[, 'time'] +1
  handover.data <- rbind(handover.data, rolling.data)
}


handover_boxplots(crossval.mice.data, handover.data, "SF_12", save.path, "crossval_SF12_boxplot")
density_ridges(crossval.mice.data, "SF_12", save=TRUE, save.path=save.path, filename.tag = "crossval_raw_ridges")
density_ridges(handover.data, "SF_12", save=TRUE, save.path=save.path, filename.tag = "crossval_validation_ridges")

```

###

```{r random_coefficients}

# for 100 iterations
randomised.mice.model.data <- data.frame()
random.mice.lm.object <- lm(mice_formula_string, data = complete(mice_set.subset, 1))


for (i in 1:100) {
  # choose a random OLS model
  # randomise its coefficients from MVN dist from MASS.
  #model.choice.ix <- ceiling(runif(1)*30)
  #model.choice <- mice.sf12.lm$analyses[model.choice.ix]
  model.choice <- random.mice.lm.object
  model.choice$coefficients <- MASS::mvrnorm(n=1, mu=mice.lm.object$coefficients[, 1], Sigma=vcov(mice.lm.object))
  # add to pool
  # commentary
  random.start.data <- crossval.mice.data[which(crossval.mice.data$time==2013),]
  #random.start.data[, c("run_id")] <- i
  #random.rolling.data <- random.start.data[, c("SF_12", "time", "run_id")]
  #random.handover.data <- rolling.data
  for (j in 1:7){
    random.start.data$SF_12 <- predict(model.choice, random.start.data)
    #random.start.data$SF_12 <- random.rolling.data$SF_12
    #random.rolling.data[, 'time'] <- random.rolling.data[, 'time'] +1
    #random.handover.data <- rbind(random.handover.data, random.rolling.data)
  }
  individual.density <- density(random.start.data$SF_12)
  new.data.frame <- cbind(individual.density$x, individual.density$y, i)
  colnames(new.data.frame) <- c("SF_12", "Density", "run_id")
  randomised.mice.model.data <- rbind(randomised.mice.model.data, new.data.frame)

}

p <- ggplot(randomised.mice.model.data, aes(x=SF_12, y=Density, group=factor(run_id))) +
     geom_line(alpha=0.1) + ylim(0, 0.15) + xlim(15,60)
ggsave(paste0(save.path, "/", "randomised_coefficients_2020_density.pdf"))
#ggplot(randomised.mice.model.data, aes(x=SF_12, y=Density)) +
#    geom_line(alpha=0.2) + geom_ribbon()



```

### LASSO and variable selection. 

```{r lasso}
# just import from old paper
lasso.data <- tidyr::drop_na(complete(mice_set.subset))
X <- model.matrix(as.formula(mice_formula_string), data=lasso.data)
y <- lasso.data$SF_12
weight <- lasso.data$weight
cv.lasso <- cv.glmnet(X, y, family = "gaussian", weights = weight)
lasso <- glmnet(X, y, alpha = 1,  family = "gaussian", weights = weight)

# plots for this. 
  
pdf(paste0(save.path, 'ols_lasso_2013.pdf'))
plot(lasso, xvar = "lambda", label = T) 
abline(v = log(cv.lasso$lambda.min), col = "blue",lty=2)
abline(v = log(cv.lasso$lambda.1se), col = "red", lty=3)
legend('bottomright', legend=c("Minimum Standard Error", "First Standard Error"), col=c('blue', 'red'), lty=c(2, 3))
dev.off()

pdf(paste0(save.path, 'ols_cv_lasso_2013.pdf'))
plot(cv.lasso)
dev.off()

# bind two sets of coefficients into a data frame
# load them into a tex table using the latex package?
lasso.min.coefs <- coef(cv.lasso, s=cv.lasso$lambda.min)
lasso.1se.coefs <- coef(cv.lasso, s=cv.lasso$lambda.1se)
lasso_model_names <- c("Minimum Error", "First Standard Error")

texreg_file <- paste0(save.path, 'SF12_Lasso_coefficients.txt')
tex_label <- paste0("table: sf12_lasso_coefficients") 
tex_headers <- c(texreg::names2latex("Minimum Error"), texreg::names2latex("First Standard Error"))
tex_caption <- texreg::names2latex(get_tex_table_caption("SF_12", "lasso"))    
#lassoTexReg <-createTexreg(coef.names=rownames(lasso_coefs), coef = lasso_coefs[,1], se=lasso_coefs[,2], model.names=c("Minimum Error", "First Standard Error"))

lasso.min <-createTexreg(coef.names=rownames(lasso_coefs), coef = lasso.min.coefs[, "s1"])
lasso.1se <-createTexreg(coef.names=rownames(lasso_coefs), coef = lasso.1se.coefs[, "s1"])


#lassoTexReg2 <-createTexreg(coef.names=rownames(lasso_coefs), coef = lasso_coefs[,2])#, lasso_coefs[, 2]))#, pvalues=lasso_coefs[,2])
#matrixLassoTexReg <- matrixreg(list(lassoTexReg, lassoTexReg2))

texreg(c(lasso.min, lasso.1se), # what model to save coefs for. 
       file=texreg_file,  # where to save.
       custom.model.names = tex_headers, # title of table.
       caption=tex_caption, # \caption command option. 
       label = tex_label, # \label command option. 
       dcolumn=T,# nice column alignment. 
       booktabs=T, # nice hlines. (recommended)
       tabular=T,# tabulr env.
       single.row = T, # nicer one row formatting.
       longtable=T, # allows tables to wrap over pages
       use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
       fontsize='small') # small font

```




```{r weighted_ols}
# weighted ols using mice data.
sf12.lm.weighted <- with(mice_set.subset, lm(as.formula(mice_formula_string), weights = weight))
summary(sf12.lm.weighted)

#coefficients go here.
texreg_file <- paste0(save.path, 'SF12_Lasso_coefficients.txt')
tex_label <- paste0("table: sf12_lasso_coefficients") 
tex_headers <- c(texreg::names2latex("SF_12 LASSO"))
tex_caption <- texreg::names2latex(get_tex_table_caption("SF_12", "lasso"))    
lassoTexReg <-createTexreg(coef.names=rownames(lasso_coefs), coef = lasso_coefs[,1], se=lasso_coefs[,2])
#lassoTexReg2 <-createTexreg(coef.names=rownames(lasso_coefs), coef = lasso_coefs[,2])#, lasso_coefs[, 2]))#, pvalues=lasso_coefs[,2])
#matrixLassoTexReg <- matrixreg(list(lassoTexReg, lassoTexReg2))

texreg(lassoTexReg, # what model to save coefs for. 
       file=texreg_file,  # where to save.
       custom.model.names = tex_headers, # title of table.
       caption=tex_caption, # \caption command option. 
       label = tex_label, # \label command option. 
       dcolumn=T,# nice column alignment. 
       booktabs=T, # nice hlines. (recommended)
       tabular=T,# tabulr env.
       single.row = T, # nicer one row formatting.
       longtable=T, # allows tables to wrap over pages
       use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
       fontsize='small') # small font

```

```{r projected_data}

##REDO THIS
## GET MICE DATA 2011-2013. UPDATE WEIGHTS

# GET MICE DAT 2016-2018

# FIT TWO REGRESSIONS AND COMPARE. PARTICULARLY ASE DIFFERENCES.

# plots as with SF12
# get data with extrpolated weights for 2013-2018
# data at data/extrapolated_weights...



# creating 2016_data
mice_set.subset.2016_2018 <- mice.long[which(mice.long$time %in% c(2016, 2017, 2018)), ]
mice_set.subset.2016_2018$pidp <- mice.2018.pidp
mice_set.subset.2016_2018$weight <- mice.2018.weights
mice_set.subset.2016_2018$time <- mice.2018.time
mice_set.subset.2016_2018 <- as.mids(mice_set.subset.2016_2018)


# getting updated weights for 2011-2013 data in 2018.
extrapolated_weights.filelist <- list.files("data/",
                       include.dirs = FALSE,
                       full.names = TRUE,
                       pattern = 'extrapolated_weights_data_[0-9]{4}.csv')[1:3]# get files for 2016-2018.

extrapolated.weights.data <- do.call(rbind, lapply(extrapolated_weights.filelist, read.csv))
extrapolated.weights.data <- replace.missing(extrapolated.weights.data)
extrapolated.weights <- extrapolated.weights.data[, c("plus_5_weight")]


# adding updated weights to MICE set. 
mice_set.subset.2011_2013.updated_weights <- mice.long[which(mice.long$time %in% c(2011, 2012, 2013)), ]
mice_set.subset.2011_2013.updated_weights$pidp <- mice.pidp
mice_set.subset.2011_2013.updated_weights$weight <- extrapolated.weights
mice_set.subset.2011_2013.updated_weights$time <- mice.time
mice_set.subset.2011_2013.updated_weights <- as.mids(mice_set.subset.2011_2013.updated_weights)

```

```{r weighted_regressions}

# weighted regression for 2016-2018 using 2011-2013 models and projected weights
sf12.lm.weighted.2013 <- pool(with(mice_set.subset.2011_2013.updated_weights, lm(as.formula(mice_formula_string), weights = weight)))



#  weighted regression for 2016-2018 using 2018 data.
sf12.lm.weighted.2018 <- pool(with(mice_set.subset.2016_2018, lm(as.formula(mice_formula_string), weights = weight)))

# compare coefficients/diagnostics?

#todo test.

texreg_file <- paste0(save.path, 'projected_weights_coefficients.txt')
tex_label <- paste0("table: sf12_projected_weights_coefficients") 
tex_headers <- c(texreg::names2latex("SF_12 2018 With 2013 Extrapolated Weights"), texreg::names2latex("SF_12 2018 With Weights"))
tex_caption <- texreg::names2latex(get_tex_table_caption("SF_12", "projectied_ols"))    
texreg(list(sf12.lm.weighted.2013,sf12.lm.weighted.2018), # what model to save coefs for. 
       file=texreg_file,  # where to save.
       custom.model.names = tex_headers, # title of table.
       stars = c(0.001, 0.01, 0.05), # p-value significance symbols. 
       digits=4, # p values significant figures.
       caption=tex_caption, # \caption command option. 
       label = tex_label, # \label command option. 
       dcolumn=T,# nice column alignment. 
       booktabs=T, # nice hlines. (recommended)
       tabular=T,# tabular env.
       single.row = T, # nicer one row formatting.
       longtable=T, # allows tables to wrap over pages
       use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
       fontsize='tiny') # small font
```

## HETEROGENEITY ###############################################################


```{r "glmm"}

# yoink transition model function pre processing
reflect <- T
yeo_johnson <- F
include_weights <- T
depend <- "SF_12"
dependent_data <- complete(mice_set.subset)$SF_12

glmm.mice.long.subset <- complete(mice_set.subset, "long", include=T)

if (reflect) {
    max_value <- nanmax(mice.data[[depend]])
    glmm.mice.long.subset[, c(depend)] <- max_value - glmm.mice.long.subset[, c(depend)] + 0.001
  }
if (yeo_johnson)
{
  yj <- yeojohnson(glmm.mice.long.subset[["SF_12"]])
  glmm.mice.long.subset[["SF_12"]] <- predict(yj)
  
  min_value <- nanmin(glmm.mice.long.subset [[depend]])
  glmm.mice.long.subset[[depend]] <- glmm.mice.long.subset[[depend]] - min_value + 0.001
}


glmm.mice.long.subset <- glmm.mice.long.subset %>%
            group_by(pidp) %>%
            #mutate(diff = .data[[dependent]] - lag(.data[[dependent]], order_by = time)) %>%
            mutate(last = lag(.data[["SF_12"]], order_by = time)) %>%
            rename_with(.fn = ~paste0('SF_12_', .), .cols = last)  # add the dependent as prefix to the calculated diff
glmm.mice.set <- as.mids(glmm.mice.long.subset)

asd <- "SF_12_last +"
glmm_model_formula_string <- "SF_12 ~ SF_12_last +
                  factor(sex) + 
                  relevel(factor(ethnicity), ref='WBI') + 
                  scale(age) + 
                  factor(education_state) + 
                  factor(S7_labour_state) + 
                  relevel(factor(NSSEC), ref=1) +
                  relevel(factor(region), ref='London') +
                  scale(hh_income) + 
                  scale(I(hh_income**2)) +
                  factor(housing_quality) +
                  factor(neighbourhood_safety) +
                  factor(loneliness) + 
                  nutrition_quality + 
                  ncigs + time +
                  (1|pidp)"

sf12.glmm.model <- with(glmm.mice.set, glmer(glmm_model_formula_string,  
               nAGQ=0, # fast but inaccurate optimiser. nAGQ=1 takes forever..
               family=Gamma(link='log')#, weights=weight# gamma family with log link.
               ))

sf12.glmm.pool <- pool(sf12.glmm.model)

# mice objects dont go in forest plot annoyingly. move coefficients over to a
# dummy lm that sjPlot::plot_models can read.
mice.glmm.object <- sf12.glmm.model$analyses[[1]]
mice.glmm.object@beta <- sf12.glmm.pool$pooled$estimate
#attr(mice.glmm.object, "beta") <- sf12.glmm.pool$estimate
#mice.glmm.object@ <- sf12.glmm.pool$std.error
#mice.glmm.object$coefficients[,3] <- sf12.glmm.pool$statistic
#mice.glmm.object$coefficients[,4] <- sf12.glmm.pool$p.value


print(r2_nakagawa(sf12.glmm.model$analyses[[1]]))

#save(sf12.glmm.model, file = paste0(save.path,"sf12_glmm.RData"))


write_coefs <- T
if (write_coefs)
{
  texreg_file <- paste0(save.path, 'SF_12_GLMM_coefficients.txt')
  tex_label <- paste0("table: GLMM_SF_12_coefficients") 
  tex_headers <- c(texreg::names2latex("SF_12 GLMM"))
  tex_caption <- texreg::names2latex(get_tex_table_caption("SF_12", "glmm"))    
  texreg(sf12.glmm.pool, # what model to save coefs for. 
         file=texreg_file,  # where to save.
         custom.model.names = tex_headers, # title of table.
         stars = c(0.001, 0.01, 0.05), # p-value significance symbols. 
         digits=4, # p values significant figures.
         caption=tex_caption, # \caption command option. 
         label = tex_label, # \label command option. 
         dcolumn=T,# nice column alignment. 
         booktabs=T, # nice hlines. (recommended)
         tabular=T,# tabular env.
         single.row = T, # nicer one row formatting.
         longtable=T, # allows tables to wrap over pages
         use.packages=F, # don't add \usepackage commands to allow for direct importing of files as inputs
         fontsize='small') # small font
}

# + rnorm(nrow(complete(glmm.mice.set ,1)), 0,0.75)
if (yeo_johnson == T) {
  glmm.fitted <- (max_value - predict(yj, predict(mice.glmm.object, type='response') + min_value #+rnorm(predict(mice.glmm.object, type='response'),0,0.2)
                                    , inverse=T))#
} else {
  glmm.fitted <-  max_value - predict(mice.glmm.object, type='response')
}


#glmm.fitted <- (max_value - predict(mice.glmm.object, type='response') + min_value + rnorm(nrow(glmm.mice.long.subset), 0, 1))
#glmm.mean <- mean(glmm.fitted)
#glmm.sd <- sd(glmm.fitted)
#glmm.fitted <- glmm.fitted * (glmm.sd/sd(raw.data$SF_12))
#glmm.fitted <- glmm.fitted - (glmm.mean*(glmm.sd/sd(raw.data$SF_12)-1))
#glmm.fitted <- trunc(glmm.fitted, 0 , 100) #+ rnorm(length(glmm.fitted),0,2)

qq_plot(scale(residuals(mice.glmm.object, type='pearson')), paste0(save.path, "glmm_qq.pdf"))
qq_plot(scale(residuals(mice.glmm.object, type='deviance')), paste0(save.path, "glmm_qq.pdf"))

residual_density_plot(res=residuals(mice.glmm.object) , file_name=paste0(save.path, "glmm_residual_density.pdf"), guide="normal")

squareRootRes <- sqrt(residuals(mice.glmm.object, type='pearson')**2)
#squareRootRes <- residuals(mice.glmm.object, type='pearson')

fitted_residuals <- as.data.frame(cbind(glmm.fitted, squareRootRes))
colnames(fitted_residuals) <- c("fitted", "sqrt_residuals")
fitted_residual_plot(fitted_residuals, paste0(save.path, "glmm_scale_location_plot.pdf"))


#TODO change cofficient and std scaling.
# - (exp coefficients. - 1)??
# start pm standard error and take above exponential formula?. 
# test exp argument in plot_model

#mice.glmm.object@beta <- mice.glmm.object@beta
  
mice.glmm.object@beta <- -mice.glmm.object@beta 
gamma_forest_plot(mice.glmm.object, paste0(save.path, "glmm_forest.pdf"))
mice.glmm.object@beta <- -mice.glmm.object@beta 

```


```{r glmm_handover_data}
# load raw composite data for glmm handovers.
crossval.glmm.data <- replace.missing(complete(mice_set.full, 1)[, append(variables, c("time", 'pidp', 'weight'))])
crossval.glmm.data <- crossval.glmm.data[which(crossval.glmm.data$time>=2013),]
crossval.glmm.data <- drop_na(crossval.glmm.data)
```

```{r glmm_handovers}

start.data <- complete(glmm.mice.set, 1)
start.data <- start.data[which(start.data$time==2013),]
start.data$SF_12 <- crossval.glmm.data[which(crossval.glmm.data$time==2013),]$SF_12
start.data <- drop_na(start.data)

handover.data <- start.data

rolling.data <- start.data
for (i in 1:7){
  if (yeo_johnson) {
      rolling.data$SF_12 <- max_value - predict(yj,  predict(mice.glmm.object, start.data, type='response',allow.new.levels=T) +min_value, inverse=T)
  }
  else {
    rolling.data$SF_12 <- max_value - predict(mice.glmm.object, start.data,type='response',allow.new.levels=T) + rnorm(nrow(rolling.data), 0, 1)
  }
  #rolling.data$SF_12 <- max_value - rolling.data$SF_12
  rolling.data$SF_12 <- trunc(rolling.data$SF_12, 0 , 100)
  rolling.data$SF_12_last <- rolling.data$SF_12
  rolling.data[, 'time'] <- rolling.data[, 'time'] +1
  handover.data <- rbind(handover.data, rolling.data)
}

handover_boxplots(crossval.glmm.data, handover.data, "SF_12", save.path, "glmm_SF12_boxplot")
density_ridges(crossval.glmm.data, "SF_12", save=TRUE, save.path=save.path, filename.tag = "glmm_raw_ridges")
density_ridges(handover.data, "SF_12", save=TRUE, save.path=save.path, filename.tag = "glmm_handover_ridges")

```