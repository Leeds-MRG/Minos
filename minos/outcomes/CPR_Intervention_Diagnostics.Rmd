---
title: "Diagnosing Child Poverty Reduction Interventions"
output:
  html_document:
    toc: true
    toc_float: true
    collapsed: false
    number_sections: true
    df_print: paged
    code_folding: hide
---

# SETUP

This document presents results from a host of interventions on child poverty, including visualisations of the change in SF_12_MCS compared with baseline.

```{r "setup", include=FALSE}

library(tidyverse)
library(ggplot2)
library(ggridges) # for densities over time plots. 
library(knitr)
library(here)
library(gghighlight)
library(spatstat)
library(ggalluvial)
library(gridExtra)
library(circlize)
library(viridis)

#workingDir <- "/home/luke/Documents/MINOS/Minos/"
workingDir <- normalizePath('../')
knitr::opts_knit$set(root.dir = workingDir)
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE
)
rm(workingDir)
```

```{r "imports", include=FALSE}
source(here::here('minos', 'utils_datain.R'))
#source(here::here('minos', 'utils_validation_vis.R'))
source(here::here('minos', 'validation', 'utils.r'))
```

```{r, include=FALSE}
#out.path <- here::here('output', 'default_config/')
out.path <- here::here('output', 'scotland_scaled/')
base.dat <- read_singular_local_out(out.path, 
                                    'baseline', 
                                    drop.dead = TRUE, 
                                    drop.zero.weight = TRUE)
int.dat <- read_singular_local_out(out.path,
                               'ChildPovertyReduction',
                               drop.dead = TRUE,
                               drop.zero.weight = TRUE)
# rel.int <- read_singular_local_out(out.path,
#                                      'ChildPovertyReductionRELATIVE_2',
#                                      drop.dead = TRUE,
#                                      drop.zero.weight = TRUE)
# abs.int <- read_singular_local_out(out.path,
#                                    'ChildPovertyReductionABSOLUTE',
#                                    drop.dead = TRUE,
#                                    drop.zero.weight = TRUE)
```



# Household Income

i.e. is the intervention working?

## All Pop

```{r}
base.inc <- base.dat %>%
  select(pidp, hidp, time, hh_income, weight) %>%
  group_by(time) %>%
  summarise(hh_income = weighted.mean(x = hh_income,w = weight, na.rm = TRUE)) %>%
  mutate(scen = 'Baseline')

int.inc <- int.dat %>%
  select(pidp, hidp, time, hh_income, weight) %>%
  group_by(time) %>%
  summarise(hh_income = weighted.mean(x = hh_income,w = weight, na.rm = TRUE)) %>%
  mutate(scen = 'Intervention')

inc <- rbind(base.inc, int.inc)

ggplot(inc, aes(x = time, y = hh_income, group = scen, color = scen, fill = scen)) +
  geom_line() +
  geom_point() +
  labs(title = 'Whole Population')

ggplot(base.dat, aes(x = hh_income, y = time, group = time)) +
  geom_density_ridges(color = 'blue', alpha = 0.3) +
  geom_density_ridges(data = int.dat, aes(color = 'red', alpha = 0.3)) +
  theme(legend.position = 'none') +
  labs(title = 'Relative Poverty Reduction Intervention - Red')
```

## Households With Children

```{r}
base.inc <- base.dat %>%
  select(pidp, hidp, time, hh_income, age, nkids, weight) %>%
  mutate(nkids_any = (nkids > 0)) %>%
  filter(nkids_any == TRUE) %>%
  group_by(time) %>%
  summarise(hh_income = weighted.mean(x = hh_income, w = weight, na.rm = TRUE)) %>%
  mutate(scen = 'Baseline')

int.inc <- int.dat %>%
  select(pidp, hidp, time, hh_income, age, nkids, weight) %>%
  mutate(nkids_any = (nkids > 0)) %>%
  filter(nkids_any = TRUE) %>%
  group_by(time) %>%
  summarise(hh_income = weighted.mean(x = hh_income, w = weight, na.rm = TRUE)) %>%
  mutate(scen = 'Intervention')

inc <- rbind(base.inc, int.inc)

ggplot(inc, aes(x = time, y = hh_income, group = scen, color = scen, fill = scen)) +
  geom_line() +
  geom_point() +
  labs(title = 'Households with Children')
```

## Boosted Pop

```{r}
boosted.pidps <- int.dat %>%
  filter(income_boosted == 'True') %>%
  select(pidp, time)

#base.inc <- merge(base.dat, boosted.pidps, by = c('pidp', 'time'))
#int.inc <- merge(int.dat, boosted.pidps, by = c('pidp', 'time'))

base.inc <- base.dat %>%
  select(pidp, hidp, time, hh_income, SF_12, weight) %>%
  inner_join(boosted.pidps, by = c("pidp", "time")) %>%
  group_by(time) %>%
  summarise(hh_income = weighted.mean(x = hh_income, w = weight, na.rm = TRUE),
            SF_12 = weighted.mean(x = SF_12, w = weight, na.rm = TRUE)) %>%
  mutate(scen = 'Baseline')

int.inc <- int.dat %>%
  select(pidp, hidp, time, hh_income, SF_12, weight) %>%
  inner_join(boosted.pidps, by = c("pidp", "time")) %>%
  group_by(time) %>%
  summarise(hh_income = weighted.mean(x = hh_income, w = weight, na.rm = TRUE),
            SF_12 = weighted.mean(x = SF_12, w = weight, na.rm = TRUE)) %>%
  mutate(scen = 'Intervention')

inc <- rbind(base.inc, int.inc)

ggplot(inc, aes(x = time, y = hh_income, group = scen, color = scen, fill = scen)) +
  geom_line() +
  geom_point()

ggplot(inc, aes(x = time, y = SF_12, group = scen, color = scen, fill = scen)) +
  geom_line() +
  geom_point()

rm(boosted.pidps)
```


```{r}
colnames(base.dat)
```


# Income by Quintile

Firstly, can't rely on the income_quintile variable as this is a variable created in start year which does not transition. Therefore we will need to calculate an income quintile variable for both dataframes.

## Density Ridges

```{r}
base.dat <- base.dat %>%
  group_by(time) %>%
  mutate(income_quint = ntile(hh_income, 5))

int.dat <- int.dat %>%
  group_by(time) %>%
  mutate(income_quint = ntile(hh_income, 5))
```


```{r}

density_plot <- function(base, int) {
  p <- ggplot(base, aes(x = hh_income, y = time, group = time)) +
    geom_density_ridges(color = 'blue', alpha = 0.3) +
    geom_density_ridges(data = int, aes(color = 'red', alpha = 0.3)) +
    theme(legend.position = 'none') +
    labs(title = 'Household Income Density Plots')
  
  return(p)
}

# p <- density_plot(base.dat, int.dat)
# 
# p <- p + facet_wrap(~ income_quint, ncol=1)
# 
# print(p)

rm(p)

# ggplot(base.dat, aes(x = hh_income, y = time, group = time)) +
#   geom_density_ridges(color = 'blue', alpha = 0.3) +
#   geom_density_ridges(data = int.dat, aes(color = 'red', alpha = 0.3)) +
#   theme(legend.position = 'none') +
#   labs(title = 'Household Income Density Plots') +
#   facet_wrap(~ income_quint, ncol=1)
```

```{r}
density_plot_quintile <- function(base, int, quintile) {
  
  base <- base %>%
    filter(income_quint == quintile) %>%
    select(pidp, time, hh_income) %>%
    rename(Baseline = hh_income)
  int <- int %>%
    filter(income_quint == quintile) %>%
    select(pidp, time, hh_income) %>%
    rename(Intervention = hh_income)
  
  combined <- merge(base, int, by = c('pidp', 'time'))
  combined <- combined %>%
    pivot_longer(cols = Baseline:Intervention,
                 names_to = 'Source',
                 values_to = 'hh_income')
  
  p <- ggplot(combined, aes(x = hh_income, y = time, group = interaction(time, Source), color = Source, fill = Source)) +
    geom_density_ridges(alpha = 0.3) +
    labs(title = 'Household Income Density Plots',
         subtitle = paste0('Quintile ', quintile))
  
  return(p)
}

density_plot_quintile(base.dat, int.dat, quintile = 1)
density_plot_quintile(base.dat, int.dat, quintile = 2)
density_plot_quintile(base.dat, int.dat, quintile = 3)
density_plot_quintile(base.dat, int.dat, quintile = 4)
density_plot_quintile(base.dat, int.dat, quintile = 5)
```
```{r}
density_plot_quintile_2 <- function(base, int, quintile) {
  base <- base %>%
    filter(income_quint == quintile) %>%
    select(pidp, time, hh_income) %>%
    rename(Baseline = hh_income)
  int <- int %>%
    select(pidp, time, hh_income) %>%
    rename(Intervention = hh_income)
  
  combined <- merge(base, int, by = c('pidp', 'time'))
  combined <- combined %>%
    pivot_longer(cols = Baseline:Intervention,
                 names_to = 'Source',
                 values_to = 'hh_income')
  
  # Calculate the 1st and 99th percentiles
  lower_cutoff <- quantile(combined$hh_income, 0.01)
  upper_cutoff <- quantile(combined$hh_income, 0.99)
  
  #filtered_combined <- combined %>%
  #  filter(hh_income > lower_cutoff, hh_income < upper_cutoff)
  
  p <- ggplot(combined, aes(x = hh_income, y = time, group = interaction(time, Source), color = Source, fill = Source)) +
    geom_density_ridges(alpha = 0.3) +
    labs(title = 'Household Income Density Plots',
         subtitle = paste0('Quintile ', quintile))
  return(p)
}

density_plot_quintile_2(base.dat, int.dat, quintile = 1)
density_plot_quintile_2(base.dat, int.dat, quintile = 2)
density_plot_quintile_2(base.dat, int.dat, quintile = 3)
density_plot_quintile_2(base.dat, int.dat, quintile = 4)
density_plot_quintile_2(base.dat, int.dat, quintile = 5)
```


### Version 3

```{r}
density_plot_quintile_3 <- function(base, int, quintile) {
  
  base <- base %>%
    filter(income_quintile == quintile) %>%
    select(pidp, time, hh_income) %>%
    rename(Baseline = hh_income)
  int <- int %>%
    filter(income_quintile == quintile) %>%
    select(pidp, time, hh_income) %>%
    rename(Intervention = hh_income)
  
  combined <- merge(base, int, by = c('pidp', 'time'))
  combined <- combined %>%
    pivot_longer(cols = Baseline:Intervention,
                 names_to = 'Source',
                 values_to = 'hh_income')
  
  # Calculate the 1st and 99th percentiles
  lower_cutoff <- quantile(combined$hh_income, 0.01)
  upper_cutoff <- quantile(combined$hh_income, 0.99)
  
  filtered_combined <- combined %>%
    filter(hh_income > lower_cutoff, hh_income < upper_cutoff)
  
  p <- ggplot(combined, aes(x = hh_income, y = time, group = interaction(time, Source), color = Source, fill = Source)) +
    geom_density_ridges(alpha = 0.3) +
    labs(title = 'Household Income Density Plots',
         subtitle = paste0('Quintile ', quintile))
  return(p)
}

density_plot_quintile_3(base.dat, int.dat, quintile = 1)
density_plot_quintile_3(base.dat, int.dat, quintile = 2)
density_plot_quintile_3(base.dat, int.dat, quintile = 3)
density_plot_quintile_3(base.dat, int.dat, quintile = 4)
density_plot_quintile_3(base.dat, int.dat, quintile = 5)
```

### Version 4

```{r}
density_plot_quintile_4 <- function(base, int, quintile) {
  
  base <- base %>%
    filter(income_quintile == quintile) %>%
    select(pidp, time, hh_income) %>%
    rename(Baseline = hh_income)
  int <- int %>%
    select(pidp, time, hh_income) %>%
    rename(Intervention = hh_income)
  
  combined <- merge(base, int, by = c('pidp', 'time'))
  combined <- combined %>%
    pivot_longer(cols = Baseline:Intervention,
                 names_to = 'Source',
                 values_to = 'hh_income')
  
  # Calculate the 1st and 99th percentiles
  lower_cutoff <- quantile(combined$hh_income, 0.01)
  upper_cutoff <- quantile(combined$hh_income, 0.99)
  
  filtered_combined <- combined %>%
    filter(hh_income > lower_cutoff, hh_income < upper_cutoff)
  
  p <- ggplot(combined, aes(x = hh_income, y = time, group = interaction(time, Source), color = Source, fill = Source)) +
    geom_density_ridges(alpha = 0.3) +
    labs(title = 'Household Income Density Plots',
         subtitle = paste0('Quintile ', quintile))
  return(p)
}

density_plot_quintile_4(base.dat, int.dat, quintile = 1)
density_plot_quintile_4(base.dat, int.dat, quintile = 2)
density_plot_quintile_4(base.dat, int.dat, quintile = 3)
density_plot_quintile_4(base.dat, int.dat, quintile = 4)
density_plot_quintile_4(base.dat, int.dat, quintile = 5)
```

## Mean Income

```{r}
mean_income_quintile <- function(base, int) {
  base <- base %>%
    select(pidp, time, hh_income, income_quint, weight) %>%
    mutate(source = 'Baseline')
  int <- int %>%
    select(pidp, time, hh_income, income_quint, weight) %>%
    mutate(source = 'Intervention')
  
  combined <- rbind(base, int)
  
  combined <- combined %>%
    group_by(time, income_quint, source) %>%
    summarise(mean = weighted.mean(hh_income, weight),
              median = weighted.median(hh_income, weight))
  
  combined$income_quint <- factor(combined$income_quint)
  combined$source <- factor(combined$source)

  
  p1 <- ggplot(combined, aes(x = time, y = mean, group = interaction(income_quint, source), color = income_quint, linetype = source, fill = income_quint)) +
    geom_line() +
    labs(title = 'Mean hh_income by quintile',
         subtitle = 'Baseline vs Intervention')
  
  p2 <- ggplot(combined, aes(x = time, y = median, group = interaction(income_quint, source), color = income_quint, linetype = source, fill = income_quint)) +
    geom_line() +
    labs(title = 'Median hh_income by quintile',
         subtitle = 'Baseline vs Intervention')
  
  print(p1)
  print(p2)
  #return(p)
}

mean_income_quintile(base.dat, int.dat)
```

```{r}
mean_income_quintile_2 <- function(base, int) {
  
  base <- base.dat %>%
    select(pidp, time, hh_income, income_quint, weight) %>%
    mutate(source = 'Baseline')
  
  # start processing to use baseline income_quint var on intervention
  base.tmp <- base %>% 
    select(-weight, -hh_income, -source)
  
  int <- int.dat %>%
    select(pidp, time, hh_income, weight)
  
  merged.int <- merge(int, base.tmp, by = c('pidp', 'time'))
  
  int <- merged.int %>%
    mutate(source = 'Intervention')
  
  
  combined <- rbind(base, int)
  
  combined <- combined %>%
    group_by(time, income_quint, source) %>%
    summarise(mean = weighted.mean(hh_income, weight),
              median = weighted.median(hh_income, weight))
  
  combined$income_quint <- factor(combined$income_quint)
  combined$source <- factor(combined$source)

  
  p1 <- ggplot(combined, aes(x = time, y = mean, group = interaction(income_quint, source), color = income_quint, linetype = source, fill = income_quint)) +
    geom_line() +
    labs(title = 'Mean hh_income by quintile',
         subtitle = 'Baseline vs Intervention')
  
  p2 <- ggplot(combined, aes(x = time, y = median, group = interaction(income_quint, source), color = income_quint, linetype = source, fill = income_quint)) +
    geom_line() +
    labs(title = 'Median hh_income by quintile',
         subtitle = 'Baseline vs Intervention')
  
  print(p1)
  print(p2)
  #return(p)
}

mean_income_quintile_2(base.dat, int.dat)
```

## Thresholds Over Time

```{r}
# get min-max by group as this is upper and lower limits of the quintiles

base <- base.dat %>%
  group_by(time, income_quint) %>%
  summarise(min = min(hh_income),
            max = max(hh_income)) %>%
  mutate(source = 'Baseline')
int <- int.dat %>%
  group_by(time, income_quint) %>%
  summarise(min = min(hh_income),
            max = max(hh_income)) %>%
  mutate(source = 'Intervention')

combined <- rbind(base, int)
combined$income_quint <- factor(combined$income_quint)

quintile_threshold_plot <- function(data, year) {
  ggplot(filter(data, time == year), 
         aes(x = income_quint, y = min,
             ymin = min, lower = min, ymax = max, upper = max,
             group = source, 
             colour = source, 
             fill = source)) +
    geom_crossbar(position = position_dodge()) +
    labs(title = 'Quintile Thresholds',
         subtitle = year)
}

quintile_threshold_plot(combined, year = 2020)
quintile_threshold_plot(combined, year = 2021)
quintile_threshold_plot(combined, year = 2025)
quintile_threshold_plot(combined, year = 2030)
quintile_threshold_plot(combined, year = 2035)
```

# Flows Between Quintiles

## Alluvial Plot

```{r}
plot_alluvial <- function(base.dat, int.dat, start_year) {
  # Prepare baseline data
  base_alluvial <- base.dat %>%
    filter(time %in% c(start_year, start_year + 1)) %>%
    select(pidp, time, income_quint) %>%
    spread(time, income_quint) %>%
    rename(Quintile_T1 = !!as.name(paste0(start_year)), 
           Quintile_T2 = !!as.name(paste0(start_year + 1))) %>%
    group_by(Quintile_T1, Quintile_T2) %>%
    summarise(count = n()) %>%
    ungroup() %>%
    mutate(scenario = "Baseline")
  
  # Prepare intervention data
  int_alluvial <- int.dat %>%
    filter(time %in% c(start_year, start_year + 1)) %>%
    select(pidp, time, income_quint) %>%
    spread(time, income_quint) %>%
    rename(Quintile_T1 = !!as.name(paste0(start_year)), 
           Quintile_T2 = !!as.name(paste0(start_year + 1))) %>%
    group_by(Quintile_T1, Quintile_T2) %>%
    summarise(count = n()) %>%
    ungroup() %>%
    mutate(scenario = "Intervention")
  
  # Combine both datasets
  combined_alluvial <- bind_rows(base_alluvial, int_alluvial)
  
  # Plot
  ggplot(combined_alluvial, aes(axis1 = Quintile_T1, 
                                axis2 = Quintile_T2, 
                                y = count)) +
    geom_alluvium(aes(fill = as.factor(Quintile_T1))) +  # Color by first quintile
    geom_stratum() +
    geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
    scale_x_discrete(limits = c(paste0(start_year), paste0(start_year + 1)), expand = c(0.15, 0.05)) +
    labs(title = "Flows between Quintiles over Time", 
         x = "Year", 
         y = "Count") +
    facet_grid(. ~ scenario) +  # Side-by-side comparison of baseline and intervention
    theme_minimal()
}


#plot_alluvial(base.dat, int.dat, 2020)
#plot_alluvial(base.dat, int.dat, 2025)
#plot_alluvial(base.dat, int.dat, 2030)
#plot_alluvial(base.dat, int.dat, 2034)
```

### Difference Alluvial

```{r}
plot_alluvial_difference_all_years <- function(base.dat, int.dat) {
  
  # Helper function to prepare alluvial data across all consecutive years
  prepare_alluvial_data_all_years <- function(data) {
    data %>%
      select(pidp, time, income_quint) %>%
      group_by(pidp) %>%
      arrange(time) %>%  # Ensure data is sorted by time
      mutate(Quintile_T1 = lag(income_quint),  # Previous year's quintile
             Quintile_T2 = income_quint) %>%   # Current year's quintile
      filter(!is.na(Quintile_T1)) %>%  # Remove rows without previous year
      group_by(Quintile_T1, Quintile_T2) %>%
      summarise(count = n()) %>%
      ungroup()
  }
  
  # Prepare baseline and intervention data for all years
  base_alluvial <- prepare_alluvial_data_all_years(base.dat) %>%
    rename(count_baseline = count)
  int_alluvial <- prepare_alluvial_data_all_years(int.dat) %>%
    rename(count_intervention = count)
  
  # Combine both datasets and calculate the difference in counts
  combined_alluvial <- base_alluvial %>%
    full_join(int_alluvial, by = c("Quintile_T1", "Quintile_T2")) %>%
    mutate(diff_count = coalesce(count_intervention, 0) - coalesce(count_baseline, 0)) %>%
    replace_na(list(diff_count = 0))  # Handle missing values
  
  # Plot the difference in flows across all years without axis labels
  ggplot(combined_alluvial, aes(axis1 = Quintile_T1, axis2 = Quintile_T2, y = abs(diff_count))) +
    geom_alluvium(aes(fill = as.factor(Quintile_T1)), width = 0.15) +
    geom_stratum(width = 0.15) +
    geom_text(stat = "stratum", aes(label = after_stat(stratum))) +
    scale_fill_viridis_d() +
    labs(title = "Difference in Flows between Quintiles: Baseline vs Intervention (All Years)") +
    theme_minimal() +
    theme(
      legend.position = "none",      # Remove legend
      axis.title = element_blank(),  # Remove axis titles
      axis.text = element_blank(),   # Remove axis text
      axis.ticks = element_blank()   # Remove axis ticks
    )
}

# Example usage:
plot_alluvial_difference_all_years(base.dat, int.dat)

```


## Heatmaps

```{r}
# Prepare data for heatmap
# df_heatmap <- base.dat %>%
#   filter(time %in% c(2020, 2021)) %>% # Select two time points
#   select(pidp, time, income_quint) %>%
#   spread(time, income_quint) %>%
#   rename(Quintile_T1 = `2020`, Quintile_T2 = `2021`) %>%
#   group_by(Quintile_T1, Quintile_T2) %>%
#   summarise(count = n()) %>%
#   ungroup() %>%
#   complete(Quintile_T1 = 1:5, Quintile_T2 = 1:5, fill = list(count = 0))
# 
# 
# ggplot(df_heatmap, aes(Quintile_T1, Quintile_T2, fill = count)) +
#   geom_tile() +
#   geom_text(aes(label = count), color = "black", size = 4) +  # Add count labels in each tile
#   scale_fill_gradient(low = "white", high = "blue") +
#   labs(title = "Transition Heatmap between Quintiles",
#        x = "Quintile at Baseline", y = "Quintile at Intervention") +
#   theme_minimal()
```


```{r}
plot_transition_heatmaps <- function(base_data, int_data) {
  
  # Helper function to process the data and prepare it for plotting
  prepare_heatmap_data <- function(data) {
    data %>%
      arrange(pidp, time) %>%  # Sort by individual and time
      group_by(pidp) %>%  # Group by individual
      mutate(Quintile_T1 = income_quint,  # Current quintile
             Quintile_T2 = lead(income_quint),  # Next year's quintile
             Year_T1 = time,  # Current year
             Year_T2 = lead(time)) %>%  # Next year
      filter(!is.na(Quintile_T2) & Year_T2 == Year_T1 + 1) %>%  # Keep only consecutive years
      ungroup() %>%
      group_by(Quintile_T1, Quintile_T2) %>%
      summarise(count = n()) %>%
      ungroup() %>%
      complete(Quintile_T1 = 1:5, Quintile_T2 = 1:5, fill = list(count = 0))  # Ensure all combinations
  }
  
  # Prepare data for baseline and intervention
  df_baseline <- prepare_heatmap_data(base_data)
  df_intervention <- prepare_heatmap_data(int_data)
  
  # Create the baseline heatmap
  p1 <- ggplot(df_baseline, aes(Quintile_T1, Quintile_T2, fill = count)) +
    geom_tile() +  # Create the heatmap
    geom_text(aes(label = count), color = "black", size = 4) +  # Add count labels in each tile
    scale_fill_gradient(low = "white", high = "blue") +  # Color gradient for the tiles
    labs(title = "Baseline Transition Heatmap",
         x = "Quintile at Year T1", y = "Quintile at Year T2") +
    theme_minimal()
  
  # Create the intervention heatmap
  p2 <- ggplot(df_intervention, aes(Quintile_T1, Quintile_T2, fill = count)) +
    geom_tile() +  # Create the heatmap
    geom_text(aes(label = count), color = "black", size = 4) +  # Add count labels in each tile
    scale_fill_gradient(low = "white", high = "blue") +  # Color gradient for the tiles
    labs(title = "Intervention Transition Heatmap",
         x = "Quintile at Year T1", y = "Quintile at Year T2") +
    theme_minimal()
  
  # Arrange the two plots side by side for comparison
  #gridExtra::grid.arrange(p1, p2, ncol = 2)
  print(p1)
  print(p2)
}

# Example usage:
#plot_transition_heatmaps(base.dat, int.dat)

```

### Difference Heatmap

```{r}
plot_transition_heatmap_difference <- function(base_data, int_data) {
  
  # Helper function to process the data and prepare it for comparison
  prepare_heatmap_data <- function(data) {
    data %>%
      arrange(pidp, time) %>%  # Sort by individual and time
      group_by(pidp) %>%  # Group by individual
      mutate(Quintile_T1 = income_quint,  # Current quintile
             Quintile_T2 = lead(income_quint),  # Next year's quintile
             Year_T1 = time,  # Current year
             Year_T2 = lead(time)) %>%  # Next year
      filter(!is.na(Quintile_T2) & Year_T2 == Year_T1 + 1) %>%  # Keep only consecutive years
      ungroup() %>%
      group_by(Quintile_T1, Quintile_T2) %>%
      summarise(count = n()) %>%
      ungroup() %>%
      complete(Quintile_T1 = 1:5, Quintile_T2 = 1:5, fill = list(count = 0))  # Ensure all combinations
  }
  
  # Prepare data for baseline and intervention
  df_baseline <- prepare_heatmap_data(base_data) %>%
    rename(count_baseline = count)
  df_intervention <- prepare_heatmap_data(int_data) %>%
    rename(count_intervention = count)
  
  # Merge the two datasets by Quintile_T1 and Quintile_T2
  df_difference <- df_baseline %>%
    left_join(df_intervention, by = c("Quintile_T1", "Quintile_T2")) %>%
    mutate(diff_count = count_intervention - count_baseline) %>%
    replace_na(list(diff_count = 0))  # Handle missing values
  
  # Plot the difference heatmap
  ggplot(df_difference, aes(Quintile_T1, Quintile_T2, fill = diff_count)) +
    geom_tile() +  # Create the heatmap
    geom_text(aes(label = diff_count), color = "black", size = 4) +  # Add difference labels in each tile
    scale_fill_gradient2(low = "red", mid = "white", high = "blue", midpoint = 0) +  # Diverging color scale
    labs(title = "Difference in Transition Counts between Baseline and Intervention",
         x = "Quintile at Year T1", y = "Quintile at Year T2",
         fill = "Count Difference") +
    theme_minimal()
}

# Example usage:
plot_transition_heatmap_difference(base.dat, int.dat)
```

## Chord Diagram

```{r}
# Function to prepare data for chord diagram
prepare_chord_data_all_years <- function(data) {
  data %>%
    select(pidp, time, income_quint) %>%
    group_by(pidp) %>%
    arrange(time) %>%  # Ensure data is sorted by time
    mutate(Quintile_T1 = lag(income_quint),  # Previous year's quintile
           Quintile_T2 = income_quint) %>%   # Current year's quintile
    filter(!is.na(Quintile_T1)) %>%  # Remove rows without previous year
    group_by(Quintile_T1, Quintile_T2) %>%
    summarise(count = n(), .groups = "drop")  # Ensure no grouping remains
}

# Function to create a chord diagram with labels
plot_chord_difference_all_years <- function(base.dat, int.dat) {
  
  # Prepare baseline and intervention data for all years
  base_chord <- prepare_chord_data_all_years(base.dat) %>%
    rename(count_baseline = count)
  int_chord <- prepare_chord_data_all_years(int.dat) %>%
    rename(count_intervention = count)
  
  # Combine both datasets and calculate the difference in counts
  combined_chord <- base_chord %>%
    full_join(int_chord, by = c("Quintile_T1", "Quintile_T2")) %>%
    mutate(diff_count = coalesce(count_intervention, 0) - coalesce(count_baseline, 0)) %>%
    replace_na(list(diff_count = 0)) %>%
    group_by(Quintile_T1, Quintile_T2) %>%
    summarise(diff_count = sum(diff_count), .groups = "drop")  # Aggregate flows
  
  # Prepare data for chord diagram (no duplicate rows)
  chord_matrix <- combined_chord %>%
    spread(Quintile_T2, diff_count, fill = 0) %>%
    column_to_rownames(var = "Quintile_T1") %>%
    as.matrix()
  
  # Define color palette for the quintiles
  chord_colors <- viridis::viridis(5)
  
  # Define labels for the quintiles
  quintile_labels <- paste("Quintile", 1:5)
  
  # Plot chord diagram with labels
  circos.clear()
  circos.par(start.degree = 90)  # Start the chord diagram from the top
  chordDiagram(chord_matrix, 
               annotationTrack = c("name", "grid"),  # Add labels and grid
               transparency = 0.5,                   # Adjust transparency of flows
               grid.col = chord_colors,              # Color by quintile
               preAllocateTracks = 1,
               directional = 1)                      # Optional: make it directional
  
  # Add labels for each quintile
  circos.track(track.index = 1, panel.fun = function(x, y) {
    circos.text(CELL_META$xcenter, CELL_META$ylim[1] + 0.1, 
                quintile_labels[CELL_META$sector.numeric.index], 
                facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
  }, bg.border = NA)
  
  # Remove axis labels and ticks
  circos.track(track.index = 1, panel.fun = function(x, y) {
    circos.axis(labels.cex = 0, labels = FALSE, major.tick = FALSE)
  })
}

# Example usage:
plot_chord_difference_all_years(base.dat, int.dat)
```

## Income Growth Trajectories

Quick bit of data prep.

```{r}
base.dat <- base.dat %>%
  select(pidp, hidp, time, income_quint, hh_income, SF_12) %>%
  mutate(scenario = 'Baseline')
int.dat <- int.dat %>%
  select(pidp, hidp, time, income_quint, hh_income, SF_12) %>%
  mutate(scenario = 'Intervention')

all.dat <- rbind(base.dat, int.dat)
```

```{r}
# Calculate average income growth by quintile and year
income_growth <- all.dat %>%
  group_by(time, income_quint, scenario) %>%
  summarise(avg_income = mean(hh_income)) %>%
  mutate(income_growth = avg_income - lag(avg_income, 1)) %>%
  filter(!is.na(income_growth))

# Plot
ggplot(income_growth, aes(x = time, y = income_growth, color = scenario)) +
  geom_line() +
  facet_wrap(~income_quint) +
  labs(title = "Income Growth by Quintile Over Time",
       x = "Year", y = "Income Growth") +
  theme_minimal()
```

## SF-12 MCS Distribution Shifts

```{r}
# Plot SF-12 MCS distribution by quintile
ggplot(all.dat, aes(x = SF_12, fill = scenario)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~income_quint) +
  labs(title = "SF-12 MCS Distribution by Quintile and Scenario",
       x = "SF-12 MCS", y = "Density") +
  theme_minimal()

# ggplot(filter(all.dat, scenario == 'Baseline'), aes(x = SF_12, fill = scenario)) +
#   geom_density(alpha = 0.5) +
#   facet_wrap(~income_quint) +
#   labs(title = "SF-12 MCS Distribution by Quintile and Scenario",
#        x = "SF-12 MCS", y = "Density") +
#   theme_minimal()
```

## Change in SF-12

```{r}
# Calculate change in SF-12 MCS by quintile and year
sf12_change <- all.dat %>%
  group_by(time, income_quint, scenario) %>%
  summarise(mean_sf12 = mean(SF_12)) %>%
  spread(scenario, mean_sf12) %>%
  mutate(sf12_diff = Intervention - Baseline)

# Plot
ggplot(sf12_change, aes(x = time, y = sf12_diff, fill = as.factor(income_quint))) +
  geom_col(position = "dodge") +
  labs(title = "Change in SF-12 MCS by Quintile",
       x = "Year", y = "SF-12 MCS Change") +
  theme_minimal()
```

## Income vs SF-12

```{r}
# Scatter plot of income change vs SF-12 MCS change by quintile
# sf12_income_corr <- all.dat %>%
#   group_by(pidp, time, income_quint, scenario) %>%
#   summarise(income_change = hh_income - lag(hh_income),
#             sf12_change = SF_12 - lag(SF_12)) %>%
#   filter(!is.na(income_change) & !is.na(sf12_change))

sf12_income_corr <- all.dat %>%
  select(pidp, time, income_quint, scenario, hh_income, SF_12) %>%
  arrange(pidp, time) %>%  # Ensure data is arranged by individual and time
  group_by(pidp, income_quint, scenario) %>%
  mutate(income_change = hh_income - lag(hh_income),  # Change in household income
         sf12_change = SF_12 - lag(SF_12)) %>%  # Change in SF-12 MCS
  filter(!is.na(income_change) & !is.na(sf12_change))  # Filter out NA changes

```

```{r}

ggplot(sf12_income_corr, aes(x = income_change, y = sf12_change, color = scenario)) +
  geom_point(alpha = 0.5) +
  facet_wrap(~income_quint) +
  labs(title = "Income Change vs. SF-12 MCS Change",
       x = "Income Change", y = "SF-12 MCS Change") +
  theme_minimal()
```


## Heatmap of SF-12 Transitions

```{r}
# Categorize SF-12 MCS transitions: "Improving", "Stable", "Worsening"
prepare_sf12_transitions <- function(data) {
  data %>%
    select(pidp, time, income_quint, SF12_MCS) %>%
    group_by(pidp) %>%
    arrange(time) %>%  # Ensure data is ordered by time
    mutate(SF12_MCS_change = SF12_MCS - lag(SF12_MCS)) %>%
    mutate(SF12_MCS_transition = case_when(
      SF12_MCS_change > 0 ~ "Improving",
      SF12_MCS_change == 0 ~ "Stable",
      SF12_MCS_change < 0 ~ "Worsening",
      TRUE ~ NA_character_
    )) %>%
    filter(!is.na(SF12_MCS_transition)) %>%
    ungroup()
}

# Prepare the data
sf12_transitions <- prepare_sf12_transitions(data)

# Calculate the count of transitions per quintile and transition type
sf12_transition_counts <- sf12_transitions %>%
  group_by(income_quint, SF12_MCS_transition) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  spread(SF12_MCS_transition, count, fill = 0)

# Normalize the counts to show proportions per quintile
sf12_transition_counts <- sf12_transition_counts %>%
  gather(SF12_MCS_transition, count, -income_quint) %>%
  group_by(income_quint) %>%
  mutate(proportion = count / sum(count)) %>%
  ungroup()

# Plot the heatmap
ggplot(sf12_transition_counts, aes(x = SF12_MCS_transition, y = as.factor(income_quint), fill = proportion)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  labs(title = "SF-12 MCS Transitions Heatmap by Quintile",
       x = "SF-12 MCS Transition", y = "Income Quintile", fill = "Proportion") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```


```{r}
# Function to prepare data for heatmap of SF-12 MCS transitions
prepare_sf12_heatmap_data <- function(data) {
  data %>%
    arrange(pidp, time) %>%  # Arrange data by individual and time
    group_by(pidp) %>%
    mutate(SF12_T1 = lag(SF_12),  # Previous year's SF-12 score
           SF12_T2 = SF_12) %>%   # Current year's SF-12 score
    filter(!is.na(SF12_T1)) %>%  # Remove rows without previous year
    group_by(SF12_T1, SF12_T2) %>%
    summarise(count = n()) %>%  # Count the number of transitions
    ungroup() %>%
    complete(SF12_T1, SF12_T2, fill = list(count = 0))  # Ensure all possible combinations
}

# Function to plot heatmap showing the differences between baseline and intervention transitions
plot_sf12_heatmap_difference <- function(base.dat, int.dat) {
  # Prepare baseline and intervention data
  base_heatmap <- prepare_sf12_heatmap_data(base.dat) %>%
    rename(count_baseline = count)
  int_heatmap <- prepare_sf12_heatmap_data(int.dat) %>%
    rename(count_intervention = count)
  
  # Combine both datasets and calculate differences in counts and proportions
  combined_heatmap <- base_heatmap %>%
    full_join(int_heatmap, by = c("SF12_T1", "SF12_T2")) %>%
    mutate(count_baseline = coalesce(count_baseline, 0),
           count_intervention = coalesce(count_intervention, 0),
           diff_count = count_intervention - count_baseline,
           total_count = count_baseline + count_intervention,
           diff_prop = ifelse(total_count > 0, diff_count / total_count, 0)) %>%
    replace_na(list(diff_count = 0, diff_prop = 0))  # Handle missing values
  
  # Plot heatmap of count differences
  count_heatmap <- ggplot(combined_heatmap, aes(SF12_T1, SF12_T2, fill = diff_count)) +
    geom_tile() +
    scale_fill_gradient2(low = "red", mid = "white", high = "blue", midpoint = 0) +
    labs(title = "Difference in SF-12 MCS Transitions (Counts)", 
         x = "SF-12 MCS (Previous Year)", 
         y = "SF-12 MCS (Current Year)", 
         fill = "Count Difference") +
    theme_minimal()
  
  # Plot heatmap of proportion differences
  prop_heatmap <- ggplot(combined_heatmap, aes(SF12_T1, SF12_T2, fill = diff_prop)) +
    geom_tile() +
    scale_fill_gradient2(low = "red", mid = "white", high = "blue", midpoint = 0) +
    labs(title = "Difference in SF-12 MCS Transitions (Proportions)", 
         x = "SF-12 MCS (Previous Year)", 
         y = "SF-12 MCS (Current Year)", 
         fill = "Proportion Difference") +
    theme_minimal()
  
  # Return both plots
  list(count_heatmap = count_heatmap, prop_heatmap = prop_heatmap)
}

# Example usage
plots <- plot_sf12_heatmap_difference(base.dat, int.dat)
plots$count_heatmap  # Display the count heatmap
plots$prop_heatmap  # Display the proportion heatmap

```








```{r}

```


# TESTING THE BOOSTED POP


```{r}
boosted.pidps <- int.dat %>%
  filter(income_boosted == 'True') %>%
  select(pidp, time)

# Define the recoding mapping for housing_quality
recoding_mapping <- c("Low" = 1, "Medium" = 2, "High" = 3)  # Adjust as needed

base.inc <- base.dat %>%
  select(pidp, hidp, time, age, hh_income, SF_12, housing_quality, neighbourhood_safety, ncigs, nutrition_quality, loneliness, nkids, weight) %>%
  inner_join(boosted.pidps, by = c("pidp", "time")) %>%
  mutate_at(vars(housing_quality), ~recode(., !!!recoding_mapping)) %>%
  group_by(time) %>%
  summarise(boosted_pop = n(),
            age = mean(age, na.rm = TRUE),
            hh_income = weighted.mean(x = hh_income, w = weight, na.rm = TRUE),
            SF_12 = weighted.mean(x = SF_12, w = weight, na.rm = TRUE),
            housing_quality = weighted.mean(x = housing_quality, w = weight, na.rm = TRUE),
            neighbourhood_safety = weighted.mean(x = neighbourhood_safety, w = weight, na.rm = TRUE),
            ncigs = weighted.mean(x = ncigs, w = weight, na.rm = TRUE),
            nutrition_quality = weighted.mean(x = nutrition_quality, w = weight, na.rm = TRUE),
            loneliness = weighted.mean(x = loneliness, w = weight, na.rm = TRUE)) %>%
  mutate(scen = 'Baseline')


int.inc <- int.dat %>%
  select(pidp, hidp, time, age, hh_income, SF_12, housing_quality, neighbourhood_safety, ncigs, nutrition_quality, loneliness, nkids, weight) %>%
  inner_join(boosted.pidps, by = c("pidp", "time")) %>%
  mutate_at(vars(housing_quality), ~recode(., !!!recoding_mapping)) %>%
  group_by(time) %>%
  summarise(boosted_pop = n(),
            age = mean(age, na.rm = TRUE),
            hh_income = weighted.mean(x = hh_income, w = weight, na.rm = TRUE),
            SF_12 = weighted.mean(x = SF_12, w = weight, na.rm = TRUE),
            housing_quality = weighted.mean(x = housing_quality, w = weight, na.rm = TRUE),
            neighbourhood_safety = weighted.mean(x = neighbourhood_safety, w = weight, na.rm = TRUE),
            ncigs = weighted.mean(x = ncigs, w = weight, na.rm = TRUE),
            nutrition_quality = weighted.mean(x = nutrition_quality, w = weight, na.rm = TRUE),
            loneliness = weighted.mean(x = loneliness, w = weight, na.rm = TRUE)) %>%
  mutate(scen = 'Intervention')

base.treated <- base.dat %>%
  select(pidp, time, hh_income, SF_12, nutrition_quality, ncigs) %>%
  inner_join(boosted.pidps, by = c("pidp", "time")) %>%
  mutate(scen = 'Baseline')

int.treated <- int.dat %>%
  select(pidp, time, hh_income, SF_12, nutrition_quality, ncigs) %>%
  inner_join(boosted.pidps, by = c("pidp", "time")) %>%
  mutate(scen = 'Intervention')

inc <- rbind(base.inc, int.inc)
treated <- rbind(base.treated, int.treated)
```

```{r}
ggplot(inc, aes(x = time, y = boosted_pop, group = scen, color = scen, fill = scen)) +
  geom_line() +
  geom_point()

ggplot(inc, aes(x = time, y = age, group = scen, color = scen, fill = scen)) +
  geom_line() +
  geom_point()

ggplot(inc, aes(x = time, y = hh_income, group = scen, color = scen, fill = scen)) +
  geom_line() +
  geom_point()

ggplot(base.treated, aes(x = hh_income, y = time, group = time, alpha = 0.3), color = 'blue') +
  geom_density_ridges() +
  geom_density_ridges(data = int.treated, aes(x = hh_income, y = time, group = time), color = 'red') +
  theme(legend.position = 'none') +
  labs(title = 'Relative Poverty Reduction Intervention - Red')

ggplot(inc, aes(x = time, y = SF_12, group = scen, color = scen, fill = scen)) +
  geom_line() +
  geom_point()

ggplot(inc, aes(x = time, y = housing_quality, group = scen, color = scen, fill = scen)) +
  geom_line() +
  geom_point()

ggplot(inc, aes(x = time, y = neighbourhood_safety, group = scen, color = scen, fill = scen)) +
  geom_line() +
  geom_point()

ggplot(inc, aes(x = time, y = ncigs, group = scen, color = scen, fill = scen)) +
  geom_line() +
  geom_point()

ggplot(inc, aes(x = time, y = nutrition_quality, group = scen, color = scen, fill = scen)) +
  geom_line() +
  geom_point()

ggplot(inc, aes(x = time, y = loneliness, group = scen, color = scen, fill = scen)) +
  geom_line() +
  geom_point()

```


```{r}
library(xgboost)
sf12 <- readRDS('/home/luke/Documents/WORK/MINOS/Minos/data/transitions/SF_12/xgb/SF_12_XGB.rds')


sf12$params
importance_matrix <- xgb.importance(model = sf12)
print(importance_matrix)

xgb.plot.importance(importance_matrix)
```



```{r}
ggplot(treated, aes(x = time, y = hh_income, group = interaction(time, scen), fill = scen)) +
  geom_boxplot()

ggplot(treated, aes(x = time, y = SF_12, group = interaction(time, scen), fill = scen)) +
  geom_boxplot()

ggplot(treated, aes(x = time, y = nutrition_quality, group = interaction(time, scen), fill = scen)) +
  geom_boxplot()

ggplot(treated, aes(x = time, y = ncigs, group = interaction(time, scen), fill = scen)) +
  geom_boxplot()
```

```{r}
base.housing <- base.dat %>%
  dplyr::select(pidp, time, housing_quality) %>%
  group_by(time, housing_quality) %>%
  count() %>%
  mutate(scen = 'Baseline')

int.housing <- int.dat %>%
  dplyr::select(pidp, time, housing_quality) %>%
  group_by(time, housing_quality) %>%
  count() %>%
  mutate(scen = 'Intervention')

housing <- rbind(base.housing, int.housing)
housing$housing_quality <- as.factor(housing$housing_quality)

housing.norm <- housing %>%
  group_by(time, scen) %>%
  mutate(total = sum(n)) %>%
  mutate(prct = (n / total))

# Plot the data
ggplot(data = housing.norm, mapping = aes(x = factor(time), y = prct, fill = housing_quality)) +
  geom_bar(stat = 'identity', position = 'stack') +
  facet_wrap(~ scen, nrow = 2) +
  labs(title = 'Housing Quality Over Time', x = 'Year', y = 'Proportion') +
  scale_y_continuous(labels = scales::percent) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplot(data = housing.norm, mapping = aes(x = factor(time), y = prct, fill = housing_quality)) +
  geom_bar(stat = 'identity', position = position_dodge(width = 0.9)) +
  facet_wrap(~ scen, nrow = 2) +
  labs(title = 'Housing Quality Over Time', x = 'Year', y = 'Proportion') +
  scale_y_continuous(labels = scales::percent) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```


```{r}
# Plot the data
ggplot(data = housing.norm, mapping = aes(x = factor(time), y = prct, fill = housing_quality)) +
  geom_bar(stat = 'identity', position = position_dodge(width = 0.8), aes(group = scen)) +
  labs(title = 'Housing Quality Over Time', x = 'Year', y = 'Proportion') +
  scale_y_continuous(labels = scales::percent) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~ scen, scales = "free_y", ncol = 2)

ggplot(data = housing.norm, mapping = aes(x = interaction(time, scen), y = prct, fill = housing_quality)) +
  geom_bar(stat = 'identity', position = 'stack') +
  labs(title = 'Housing Quality Over Time', x = 'Year and Scenario', y = 'Proportion') +
  scale_y_continuous(labels = scales::percent) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

```{r}
# Create a combined variable for interspersed plotting
housing.norm2 <- housing.norm %>%
  mutate(year_scen = interaction(time, scen, sep = " - "))

# Plot the data
ggplot(data = housing.norm2, mapping = aes(x = year_scen, y = prct, fill = housing_quality)) +
  geom_bar(stat = 'identity', position = 'stack') +
  labs(title = 'Housing Quality Over Time', x = 'Year and Scenario', y = 'Proportion') +
  scale_y_continuous(labels = scales::percent) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


```{r}
# Prepare data for line plot
housing.norm3 <- housing %>%
  group_by(time, scen, housing_quality) %>%
  summarize(prct = sum(n) / sum(housing$n)) %>%
  ungroup()

# Line plot with faceting by scenario
ggplot(data = housing.norm3, mapping = aes(x = time, y = prct, color = housing_quality, group = housing_quality)) +
  geom_line(size = 1.2) +
  geom_point(size = 3) +
  facet_wrap(~ scen) +
  labs(title = 'Housing Quality Over Time by Scenario', x = 'Year', y = 'Proportion') +
  scale_y_continuous(labels = scales::percent) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```


```{r}
# Generate proportions
housing.norm5 <- housing %>%
  group_by(time, scen) %>%
  mutate(total = sum(n)) %>%
  mutate(prct = (n / total)) %>%
  ungroup()

# Create a combined variable for interspersed plotting
housing.norm5 <- housing.norm5 %>%
  mutate(year_scen = interaction(time, scen, sep = " - "))

# Plot the data with different color schemes
ggplot(data = housing.norm5, mapping = aes(x = factor(time), y = prct, fill = housing_quality, group = scen)) +
  geom_bar(stat = 'identity', position = position_dodge(width = 0.9)) +
  facet_wrap(~ scen, ncol = 1) +
  labs(title = 'Housing Quality Over Time', x = 'Year', y = 'Proportion') +
  scale_y_continuous(labels = scales::percent) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```








# BOTTOM

```{r}

```








